using Microsoft.Protocols.TestSuites.MS_OXCFXICS;
using Microsoft.Modeling;
using Microsoft.Protocols.TestSuites.Common;

// The main configuration for MS-OXCFXICS.
config Actions 
{
    action all IMS_OXCFXICSAdapter;

    switch StepBound = 100000;
    switch StateBound = 100000;
    switch StackDepth = 100000;
    switch PathDepthBound = 100000;
    switch ConstraintSolverTimeout = 6000000;
    switch TestClassBase = "PTF";
    switch GeneratedTestPath = "..\\TestSuite";
    switch GeneratedTestNamespace = "Microsoft.Protocols.TestSuites.MS_OXCFXICS";
    switch TestEnabled = false;
    switch ForExploration = true;
    switch TestCaseName = "MSOXCFXICS_$MachineName$";
}

// Configure for generic folder in Scenario S01_SyncFastTransferFolder
config SyncFastTransferFolder : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.Move);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.Move);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyFolder(int serverId,int sourceHandleIndex,CopyFolderCopyFlags copyFlag,SendOptionAlls option,out int copyFolderHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyFolderCopyFlags>(copyFlag,CopyFolderCopyFlags.CopySubfolders,CopyFolderCopyFlags.Move);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};
}

//This machine is designed to define the operation sequencing for FastTransfer download folder operation.
//constraint value to parameters for testing
machine S01_SyncFastTransferFolder_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int DownloadHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        int subFolderIdIndex,
        int subFolderHandleIndex,
        int transferBufferIndex,
        Sequence<string> PropertyTags,
        Sequence<string> PropertyTagsForCopyTo
        where
        {.
              Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName").Add("PidTagContainerHierarchy").Add("PidTagFolderAssociatedContents").Add("PidTagContainerContents"));
              Condition.In<Sequence<string>>(PropertyTagsForCopyTo,(new Sequence<string>()).Add("PidTagAccess"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
					CreateFolder(_,newFolderHandleIndex,"SubFolder",out subFolderIdIndex,out subFolderHandleIndex);
					CreateMessage(_, newFolderHandleIndex, newFolderIdIndex, false, out messageHandleIndex);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex);
					(
						(CheckRequirementEnabled(3442001, out _);
						FastTransferSourceCopyTo(_,newFolderHandleIndex,InputHandleType.FolderHandle,_ ,_ ,_,PropertyTagsForCopyTo,out DownloadHandleIndex);)
						|
						(CheckRequirementEnabled(3466, out _);
						FastTransferSourceCopyProperties(_,newFolderHandleIndex,InputHandleType.FolderHandle,_,_,_,PropertyTags,out DownloadHandleIndex);)
						|
						(CheckRequirementEnabled(526001, out _); // Modify the logical
						FastTransferSourceCopyFolder(_,newFolderHandleIndex,_,_,out DownloadHandleIndex);)
					);
					FastTransferSourceGetBuffer(1,DownloadHandleIndex,BufferSize.Normal,out transferBufferIndex,out _,out _);
					Release(_, newFolderHandleIndex);
					Release(_, subFolderHandleIndex);
					Release(_, messageHandleIndex);
					Release(_, DownloadHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S01_SyncFastTransferFolder_Scenario machine.
machine S01_SyncFastTransferFolder_SlicedModel() : Actions
{
	S01_SyncFastTransferFolder_Scenario()
	||
    (construct model program from SyncFastTransferFolder where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferFolder machine.
machine S01_SyncFastTransferFolder_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferFolder_SlicedModel
}

// Configure for Ghosted folder in Scenario S01_SyncFastTransferFolder
config SyncFastTransferGhostedFolder : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PublicFolderServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Ghosted);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode|SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyFolder(int serverId,int sourceHandleIndex,CopyFolderCopyFlags copyFlag,SendOptionAlls option,out int copyFolderHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.Unicode);
        Condition.In<CopyFolderCopyFlags>(copyFlag, CopyFolderCopyFlags.CopySubfolders);
    .};
}

// This machine is designed to define the operation sequencing for FastTransfer download Ghosted folder operation.
// constraint value to parameters for testing
machine S01_SyncFastTransferGhostedFolder_Scenario() : SyncFastTransferGhostedFolder
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int DownloadHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        bool ghostedFolderSupported,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName").Add("PidTagEcWarning"));

        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
				return CheckMAPIHTTPTransportSupported(out true);
					call CheckSecondSUTOnline(out _);
					(
					   return CheckSecondSUTOnline(out false);
					   |
					   (
						return CheckSecondSUTOnline(out true);
						CheckRequirementEnabled(1111,out _); 
						Connect;
						Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
						OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
						CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
						//implement Download context.            
						FastTransferSourceCopyFolder(1,inboxFolderHandleIndex,_,_,out DownloadHandleIndex);         
						FastTransferSourceGetBuffer(1,DownloadHandleIndex,BufferSize.Normal,out _,out _,out _);
						DeleteFolder(1,inboxFolderHandleIndex,newFolderIdIndex);
						Release(_, DownloadHandleIndex);
						)
					)
				)
				|
			    return CheckMAPIHTTPTransportSupported(out false);
           );
        )
    )
}

// Sliced model based on the S01_SyncFastTransferGhostedFolder_Scenario machine.
machine S01_SyncFastTransferGhostedFolder_SlicedModel() : Actions
{
	S01_SyncFastTransferGhostedFolder_Scenario()
	||
    (construct model program from SyncFastTransferGhostedFolder where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

// This machine is designed to generate test case for 
// S01_SyncFastTransferGhostedFolder machine.
machine S01_SyncFastTransferGhostedFolder_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferGhostedFolder_SlicedModel()
}

//This machine is designed to define the operation sequencing for FastTransfer download Ghosted folder operation.
//constraint value to parameters for testing
machine S01_SyncFastTransferReplica_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int DownloadHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        bool ghostedFolderSupported,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName").Add("PidTagEcWarning"));

        .}

        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					call CheckSecondSUTOnline(out _);
					(
					   return CheckSecondSUTOnline(out false);
					   |
					   (
							return CheckSecondSUTOnline(out true);
							call CheckRequirementEnabled(1111,out _);
							(
								return CheckRequirementEnabled(1111,out false);
								|
								(
									return CheckRequirementEnabled(1111,out true);
									Connect;
									Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
									OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
									CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
									//implement Download context.
									(
									FastTransferSourceCopyTo(1,inboxFolderHandleIndex,InputHandleType.FolderHandle,false,_ ,_,PropertyTags,out DownloadHandleIndex);
									);
									CheckRequirementEnabled(1113,out _);
									FastTransferSourceGetBuffer(1,DownloadHandleIndex,BufferSize.Normal,out _,out _,out _);
									DeleteFolder(1,inboxFolderHandleIndex,newFolderIdIndex);
									Release(_, DownloadHandleIndex);
								)                       
							)
					    )
					)
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
           );
        )
    )
}

// Sliced model based on the S01_SyncFastTransferReplica_Scenario machine.
machine S01_SyncFastTransferReplica_SlicedModel() : Actions
{
	S01_SyncFastTransferReplica_Scenario()
	||
    (construct model program from SyncFastTransferGhostedFolder where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferReplica_TestSuite machine.
machine S01_SyncFastTransferReplica_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferReplica_SlicedModel
}

// Configure for invalid parameter in Scenario S01_SyncFastTransferFolder
config SyncFastTransferInvalidParameter : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Invalid);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.None, CopyToCopyFlags.Invalid);
        Combination.Isolated(option == SendOptionAlls.Invalid);
        Combination.Isolated(copyFlag == CopyToCopyFlags.Invalid);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Invalid);
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.None,CopyPropertiesCopyFlags.Invalid);
        Combination.Isolated(option == SendOptionAlls.Invalid);
        Combination.Isolated(copyFlag == CopyPropertiesCopyFlags.Invalid);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyMessages(int serverId, int sourceHandleIndex, RopFastTransferSourceCopyMessagesCopyFlags copyFlag, SendOptionAlls option,Sequence<int> messageIds, out int copyMessageHandleIndex)
    where{.
        Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyFlag,RopFastTransferSourceCopyMessagesCopyFlags.BestBody);
        Condition.In<SendOptionAlls>(option,SendOptionAlls.Invalid);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyFolder(int serverId,int sourceHandleIndex,CopyFolderCopyFlags copyFlag,SendOptionAlls option,out int copyFolderHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Invalid);
        Condition.In<CopyFolderCopyFlags>(copyFlag,CopyFolderCopyFlags.CopySubfolders, CopyFolderCopyFlags.Invalid);
        Combination.Isolated(option == SendOptionAlls.Invalid);
        Combination.Isolated(copyFlag == CopyFolderCopyFlags.Invalid);
    .};
}

// This machine is designed to define the operation sequencing for FastTransfer download operation with Invalid parameter.
// constraint value to parameters for testing
machine S01_SyncFastTransferInvalidParameter_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int DownloadHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        int subFolderIdIndex,
        int subFolderHandleIndex,
        Sequence<int> messageIds,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
					CreateFolder(_,newFolderHandleIndex,"SubFolder",out subFolderIdIndex,out subFolderHandleIndex);
					CreateMessage(_, newFolderHandleIndex, newFolderIdIndex, false, out messageHandleIndex);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex):
					{.
						Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(messageIdIndex));
					.};
					(
						(CheckRequirementEnabled(3445, out _); // Modify the logical
						CheckRequirementEnabled(3463, out _); // Modify the logical
						FastTransferSourceCopyTo(_,inboxFolderHandleIndex,InputHandleType.FolderHandle,false,_ ,_,PropertyTags,out DownloadHandleIndex);)
						|
						(CheckRequirementEnabled(3466, out _); // Modify the logical
						CheckRequirementEnabled(3470, out _);
						FastTransferSourceCopyProperties(_,inboxFolderHandleIndex,InputHandleType.FolderHandle,false,_,_,PropertyTags,out DownloadHandleIndex);)
						|
						(
						CheckRequirementEnabled(3479, out _); // Modify the logical
						CheckRequirementEnabled(211601, out _);
						CheckRequirementEnabled(499003, out _);
						FastTransferSourceCopyMessages(_,newFolderHandleIndex,_,_,messageIds, out DownloadHandleIndex);)
						|
						(
						CheckRequirementEnabled(3483, out _); // Modify the logical
						CheckRequirementEnabled(3487, out _);
						FastTransferSourceCopyFolder(_,inboxFolderHandleIndex,_,_,out DownloadHandleIndex);)
					);
					Release(_, newFolderHandleIndex);
					Release(_, subFolderHandleIndex);
					Release(_, messageHandleIndex);
					Release(_, DownloadHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
           );
        )
    )
}

// Sliced model based on the S01_SyncFastTransferInvalidParameter_Scenario machine.
machine S01_SyncFastTransferInvalidParameter_SlicedModel() : Actions
{
	S01_SyncFastTransferInvalidParameter_Scenario()
	||
    (construct model program from SyncFastTransferInvalidParameter where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferInvalidParameter_TestSuite machine.
machine S01_SyncFastTransferInvalidParameter_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferInvalidParameter_SlicedModel
}

// Configure for permission in Scenario S01_SyncFastTransferFolder
config SyncFastTransferPermissions : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PublicFolderServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.PublicFolder);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode );
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.Move);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode );
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.Move);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyMessages(int serverId, int sourceHandleIndex, RopFastTransferSourceCopyMessagesCopyFlags copyFlag, SendOptionAlls option,Sequence<int> messageIds, out int copyMessageHandleIndex)
    where{.
        Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyFlag,RopFastTransferSourceCopyMessagesCopyFlags.Move);
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode );
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyFolder(int serverId,int sourceHandleIndex,CopyFolderCopyFlags copyFlag,SendOptionAlls option,out int copyFolderHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode );
        Condition.In<CopyFolderCopyFlags>(copyFlag, CopyFolderCopyFlags.Move );
    .};

    action RopResult IMS_OXCFXICSAdapter.ModifyPermissions(int serverId, int folderHandleIndex, PermissionLevels permissionLevel)
    where{.
        Condition.In<PermissionLevels>(permissionLevel,PermissionLevels.FolderVisible,PermissionLevels.Owner,PermissionLevels.None);
    .};
}

// This machine is designed to define the operation sequencing for FastTransfer download operation with object that the client has no permission to visit.
// constraint value to parameters for testing
machine S01_SyncFastTransferPermissions_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int DownloadHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        int subFolderIdIndex,
        int subFolderHandleIndex,
        int subFolderMessageHandle,
        PermissionLevels permission,
        Sequence<int> messageIds,
        Sequence<string> SetPropertyTags,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName").Add("PidTagEcWarning"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody"));
            Condition.In<PermissionLevels>(permission, PermissionLevels.None, PermissionLevels.FolderVisible);
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
					CreateFolder(_,newFolderHandleIndex,"SubFolder",out subFolderIdIndex,out subFolderHandleIndex);

					CreateMessage(_, subFolderHandleIndex, subFolderIdIndex, false, out subFolderMessageHandle);
					SetProperties(_,subFolderMessageHandle,SetPropertyTags);
					SaveChangesMessage(_, subFolderMessageHandle, out _);

					CreateMessage(_, newFolderHandleIndex, newFolderIdIndex, false, out messageHandleIndex);
					SetProperties(_,messageHandleIndex,SetPropertyTags);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex):
					{.
						Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(messageIdIndex));
					.};
                ModifyPermissions(_,subFolderHandleIndex,permission);
					(
						(CheckRequirementEnabled(2667, out _);
						CheckRequirementEnabled(3442001, out _);
						FastTransferSourceCopyTo(_,newFolderHandleIndex,InputHandleType.FolderHandle,false,_ ,_,PropertyTags,out DownloadHandleIndex);)
						|
						(
						CheckRequirementEnabled(2669, out _);
						CheckRequirementEnabled(3466, out _);
						FastTransferSourceCopyProperties(_,newFolderHandleIndex,InputHandleType.FolderHandle,false,_,_,PropertyTags,out DownloadHandleIndex);
						)|
						(
						CheckRequirementEnabled(2631, out _); 
						FastTransferSourceCopyMessages(_,subFolderHandleIndex,_,_,messageIds, out DownloadHandleIndex);)
						|
						(CheckRequirementEnabled(526001, out _); // Modify the logical
						FastTransferSourceCopyFolder(_,newFolderHandleIndex,_,_,out DownloadHandleIndex);)
					);
					CheckRequirementEnabled(34381, out _);
					CheckRequirementEnabled(1168, out _); 
                    CheckRequirementEnabled(118201, out _);
					
					FastTransferSourceGetBuffer(_,DownloadHandleIndex,BufferSize.Normal,out _,out _,out _);
					call CheckRequirementEnabled(2813, out _);
					(
						(return CheckRequirementEnabled(2813,out true);
						ModifyPermissions(_,subFolderHandleIndex,PermissionLevels.Owner);)    
						|
						(return CheckRequirementEnabled(2813,out false);)
					);
					Release(_, newFolderHandleIndex);
					Release(_, subFolderHandleIndex);
					Release(_, messageHandleIndex);
					Release(_, DownloadHandleIndex);
				)	
				|
			    return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S01_SyncFastTransferPermissions_Scenario machine.
machine S01_SyncFastTransferPermissions_SlicedModel() : Actions
{
	S01_SyncFastTransferPermissions_Scenario()
	||
    (construct model program from SyncFastTransferPermissions where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferPermissions_TestSuite machine.
machine S01_SyncFastTransferPermissions_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferPermissions_SlicedModel
}

// Configure for unused flag in Scenario S01_SyncFastTransferFolder
config SyncFastTransferUnusedFlag : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
}

// This machine is designed to define the operation sequencing for FastTransfer download operation with Unused flags.
// constraint value to parameters for testing
machine S01_SyncFastTransferUnusedFlag_Scenario() : Actions
{
     (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        int subFolderHandleIndex,
        // Download Handle index
        int DownloadHandleIndex1,
        int DownloadHandleIndex2,
        // CopyFlags
        CopyToCopyFlags copyToCopyFlags,
        CopyPropertiesCopyFlags copyPropertiesCopyFlags,
        RopFastTransferSourceCopyMessagesCopyFlags copyMessageCopyFlags,
        RopFastTransferSourceCopyMessagesCopyFlags copyMessageCopyFlags1,
        //CopyFolderCopyFlags copyFolderCopyFlags,
        //CopyFolderCopyFlags copyFolderCopyFlags1,
        // BufferIndex
        int firstBufferIndex,
        int secondBufferindex,
        int thirdBUfferIndex,
        Sequence<int> messageIds,
        Sequence<string> SetPropertyTags,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody"));

            Condition.In<CopyToCopyFlags>(copyToCopyFlags,CopyToCopyFlags.Move|CopyToCopyFlags.Unused1|CopyToCopyFlags.Unused2|CopyToCopyFlags.Unused3|CopyToCopyFlags.Unused4|CopyToCopyFlags.Unused5);

            Condition.In<CopyPropertiesCopyFlags>(copyPropertiesCopyFlags,CopyPropertiesCopyFlags.Unused1|CopyPropertiesCopyFlags.Unused2|CopyPropertiesCopyFlags.Unused3);

            Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyMessageCopyFlags,RopFastTransferSourceCopyMessagesCopyFlags.Move|RopFastTransferSourceCopyMessagesCopyFlags.Unused1|RopFastTransferSourceCopyMessagesCopyFlags.Unused2);
            Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyMessageCopyFlags1,RopFastTransferSourceCopyMessagesCopyFlags.Move|RopFastTransferSourceCopyMessagesCopyFlags.Unused3);
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(_, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
					CreateFolder(_,newFolderHandleIndex,"SubFolder",out _,out subFolderHandleIndex);
					CreateMessage(_, newFolderHandleIndex, newFolderIdIndex, false, out messageHandleIndex);
					SetProperties(_,messageHandleIndex,SetPropertyTags);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex):
					{.
						Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(messageIdIndex));
					.};
					
					(
						(

							CheckRequirementEnabled(3442001 ,out _);
							FastTransferSourceCopyTo(_,newFolderHandleIndex,InputHandleType.FolderHandle,false,CopyToCopyFlags.Move,SendOptionAlls.Unicode,PropertyTags,out DownloadHandleIndex1);
							FastTransferSourceGetBuffer(_,DownloadHandleIndex1,BufferSize.Normal,out firstBufferIndex,out _,out _);
							FastTransferSourceCopyTo(_,newFolderHandleIndex,InputHandleType.FolderHandle,false,copyToCopyFlags ,SendOptionAlls.Unicode,PropertyTags,out DownloadHandleIndex2);
							FastTransferSourceGetBuffer(_,DownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
							AreEqual(EnumFastTransferOperation.FastTransferSourceCopyTo,firstBufferIndex,secondBufferindex):
							{.
								ModelHelper.CaptureRequirement(2707,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [CopyFlags] Reply is the same whether 0x00000002[Unused1] is set or not.");
								ModelHelper.CaptureRequirement(2708,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [CopyFlags] Reply is the same whether 0x00000004[Unused2] is set or not.");
								ModelHelper.CaptureRequirement(2709,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [CopyFlags] Reply is the same whether 0x00000008[Unused3] is set or not.");
								ModelHelper.CaptureRequirement(2710,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [CopyFlags] Reply is the same whether 0x00000200[Unused4] is set or not.");
								ModelHelper.CaptureRequirement(2711,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [CopyFlags] Reply is the same whether 0x00000400[Unused5] is set or not.");
							.};
						)|
						(   
							FastTransferSourceCopyProperties(_,newFolderHandleIndex,InputHandleType.FolderHandle,false,CopyPropertiesCopyFlags.Unused1,SendOptionAlls.RecoverMode ,PropertyTags,out DownloadHandleIndex1);
							FastTransferSourceGetBuffer(_,DownloadHandleIndex1,BufferSize.Normal,out firstBufferIndex,out _,out _);
							FastTransferSourceCopyProperties(_,newFolderHandleIndex,InputHandleType.FolderHandle,false,copyPropertiesCopyFlags,SendOptionAlls.RecoverMode ,PropertyTags,out DownloadHandleIndex2);
							FastTransferSourceGetBuffer(_,DownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
							AreEqual(EnumFastTransferOperation.FastTransferSourceCopyProperties,firstBufferIndex,secondBufferindex):
							{.
								ModelHelper.CaptureRequirement(2712,"[In RopFastTransferSourceCopyProperties ROP Request Buffer] [CopyFlags] Reply is the same whether Unused1(0x02) is set or not.");
								ModelHelper.CaptureRequirement(2713,"[In RopFastTransferSourceCopyProperties ROP Request Buffer] [CopyFlags] Reply is the same whether Unused2(0x04) is set or not.");
								ModelHelper.CaptureRequirement(2714,"[In RopFastTransferSourceCopyProperties ROP Request Buffer] [CopyFlags] Reply is the same whether Unused3(0x08) is set or not.");
							.};
						  )|
						(   
							FastTransferSourceCopyMessages(_,newFolderHandleIndex,RopFastTransferSourceCopyMessagesCopyFlags.Unused1,SendOptionAlls.RecoverMode ,messageIds,out DownloadHandleIndex1);
							FastTransferSourceGetBuffer(_,DownloadHandleIndex1,BufferSize.Normal,out firstBufferIndex,out _,out _);
							FastTransferSourceCopyMessages(_,newFolderHandleIndex,RopFastTransferSourceCopyMessagesCopyFlags.Unused2,SendOptionAlls.RecoverMode ,messageIds,out DownloadHandleIndex2);
							FastTransferSourceGetBuffer(_,DownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
							AreEqual(EnumFastTransferOperation.FastTransferSourceCopyProperties,firstBufferIndex,secondBufferindex):
							{.
								ModelHelper.CaptureRequirement(2715,"[In RopFastTransferSourceCopyMessages ROP Request Buffer] [CopyFlags] Reply is the same whether Unused1(0x02) is set or not.");
								ModelHelper.CaptureRequirement(2716,"[In RopFastTransferSourceCopyMessages ROP Request Buffer] [CopyFlags] Reply is the same whether 0x04[Unused2] is set or not.");
							.};
						  );
					);
					Release(_, DownloadHandleIndex1);
					Release(_, DownloadHandleIndex2);
					Release(_,messageHandleIndex);
				)
				|
			   return CheckMAPIHTTPTransportSupported(out false);
			);
		)
    )
}

// Sliced model based on the S01_SyncFastTransferUnusedFlag_Scenario machine.
machine S01_SyncFastTransferUnusedFlag_SlicedModel() : Actions
{
	S01_SyncFastTransferUnusedFlag_Scenario()
	||
    (construct model program from SyncFastTransferUnusedFlag where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferUnusedFlag_TestSuite machine.
machine S01_SyncFastTransferUnusedFlag_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferUnusedFlag_SlicedModel
}

//Configure for move flag in Scenario S01_SyncFastTransferMoveFlag
config LogonAsPrivate : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
}

//This machine is designed to define the operation sequencing for FastTransfer download folder operation.
//constraint value to parameters for testing
machine S01_SyncFastTransferCopyFolder_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int DownloadHandleIndex,
        int messageIdIndex,
        int messageHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        int subFolderIdIndex,
        int subFolderHandleIndex,
        int transferBufferIndex
        in
        (
            call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(1,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
					CreateFolder(1,newFolderHandleIndex,"SubFolder",out subFolderIdIndex,out subFolderHandleIndex);
					CreateMessage(1, newFolderHandleIndex, newFolderIdIndex, false, out messageHandleIndex);
					SaveChangesMessage(1, messageHandleIndex, out messageIdIndex);
					(
						FastTransferSourceCopyFolder(1,newFolderHandleIndex,CopyFolderCopyFlags.CopySubfolders,SendOptionAlls.RecoverMode,out DownloadHandleIndex);
						|
						FastTransferSourceCopyFolder(1,newFolderHandleIndex,CopyFolderCopyFlags.None,SendOptionAlls.RecoverMode,out DownloadHandleIndex);
					);
					FastTransferSourceGetBuffer(1,DownloadHandleIndex,BufferSize.Normal,out transferBufferIndex,out _,out _);
					Release(1, newFolderHandleIndex);
					Release(1, subFolderHandleIndex);
					Release(1, messageHandleIndex);
					Release(1, DownloadHandleIndex);
				)
				|
			    return CheckMAPIHTTPTransportSupported(out false);
			);
		)
    )
}

// Sliced model based on the S01_SyncFastTransferCopyFolder_Scenario machine.
machine S01_SyncFastTransferCopyFolder_SlicedModel() : Actions
{
	S01_SyncFastTransferCopyFolder_Scenario()
	||
    (construct model program from LogonAsPrivate where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferCopyFolder_TestSuite machine.
machine S01_SyncFastTransferCopyFolder_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferCopyFolder_SlicedModel
}

//This machine is designed to define the operation sequencing for FastTransfer download operation with Unused flags.
//constraint value to parameters for testing
machine S01_SyncFastTransferMoveFlag_Scenario() : Actions
{
     (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int newFolderIdIndex,
        int newFolderHandleIndex,
        //Download Handle index
        int DownloadHandleIndex1,
        int DownloadHandleIndex2,
        //BufferIndex
        int firstBufferIndex,
        int secondBufferindex
        
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					call CheckRequirementEnabled(3793001 ,out _);
					(
						return CheckRequirementEnabled(3793001 ,out true);
						OpenFolder(_, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
						CreateFolder(_,inboxFolderHandleIndex,"TestFolder",out newFolderIdIndex,out newFolderHandleIndex);
						FastTransferSourceCopyFolder(_,newFolderHandleIndex,CopyFolderCopyFlags.None,SendOptionAlls.Unicode , out DownloadHandleIndex1);
						FastTransferSourceGetBuffer(_,DownloadHandleIndex1,BufferSize.Normal,out firstBufferIndex,out _,out _);
						CheckRequirementEnabled(526001,out _);
						FastTransferSourceCopyFolder(_,newFolderHandleIndex,CopyFolderCopyFlags.Move,SendOptionAlls.Unicode , out DownloadHandleIndex2);
						FastTransferSourceGetBuffer(_,DownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
						AreEqual(EnumFastTransferOperation.FastTransferSourceCopyProperties,firstBufferIndex,secondBufferindex):
						{.
							ModelHelper.CaptureRequirement(3793001,"[In Appendix A: Product Behavior] Implementation does support the server return the same result whether the flag [Move] is set or not on receipt. (<6> Section 2.2.3.1.1.4.1: Exchange 2010 and Exchange 2013 follows this behavior.)");
						.};
						
						Release(_, DownloadHandleIndex1);
						Release(_, DownloadHandleIndex2);
						|
						return  CheckRequirementEnabled(3793001 ,out false);
				    );
				)
			   |
			   return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S01_SyncFastTransferMoveFlag_Scenario machine.
machine S01_SyncFastTransferMoveFlag_SlicedModel() : Actions
{
	S01_SyncFastTransferMoveFlag_Scenario()
	||
    (construct model program from LogonAsPrivate where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferMoveFlag_TestSuite machine.
machine S01_SyncFastTransferMoveFlag_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S01_SyncFastTransferMoveFlag_SlicedModel
}

// Configure for normal message in Scenario S02_SyncFastTransferMessage
config SyncFastTransferMessage : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<bool>(level,false);
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.BestBody, CopyToCopyFlags.Move, CopyToCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<bool>(level,false);
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.Move);
        
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyMessages(int serverId, int sourceHandleIndex, RopFastTransferSourceCopyMessagesCopyFlags copyFlag, SendOptionAlls option,Sequence<int> messageIds, out int copyMessageHandleIndex)
    where{.
        Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyFlag,RopFastTransferSourceCopyMessagesCopyFlags.BestBody, RopFastTransferSourceCopyMessagesCopyFlags.SendEntryId,RopFastTransferSourceCopyMessagesCopyFlags.Move );
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};
}

// This machine is designed to define the operation sequencing for FastTransfer download message operation.
// constraint value to parameters for testing
machine S02_SyncFastTransferMessage_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageHandleIndex,
        int messageIdIndex,
        int attachmentHandleIndex,
        int messageDownloadHandleIndex,
        Sequence<string> PropertyTags,
        Sequence<string> SetPropertyTags,
        Sequence<int> messageIds
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName").Add("PidTagMessageRecipients").Add("PidTagMessageAttachments").Add("PidTagBody"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					CheckRequirementEnabled(2117002, out _);
					CheckRequirementEnabled(499001, out _);
					CheckRequirementEnabled(1168, out _);
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(_, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					// Create an message in the inbox folder
					CreateMessage(_, inboxFolderHandleIndex, inboxFolderIdIndex,false, out messageHandleIndex);
					SetProperties(_,messageHandleIndex,SetPropertyTags);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex);
					// Create an attachment for the new created message
					CreateAttachment(_,messageHandleIndex,out attachmentHandleIndex);
					SaveChangesAttachment(_,attachmentHandleIndex);
					{.
						Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(messageIdIndex));
					.}:
					(
						(
						CheckRequirementEnabled(3442001, out _);
						CheckRequirementEnabled(211501, out _);
						CheckRequirementEnabled(3118003, out _);
						FastTransferSourceCopyTo(_,messageHandleIndex,InputHandleType.MessageHandle,_ ,_ ,_,PropertyTags,out messageDownloadHandleIndex);)
						|
						(
						CheckRequirementEnabled(3466, out _);
						FastTransferSourceCopyProperties(_,messageHandleIndex,InputHandleType.MessageHandle,false,_,_,PropertyTags,out messageDownloadHandleIndex);)
						|
						FastTransferSourceCopyMessages(_,inboxFolderHandleIndex,_,_,messageIds, out messageDownloadHandleIndex);
					);
					Release(_, messageHandleIndex);
					Release(_, messageDownloadHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S02_SyncFastTransferMessage_Scenario machine.
machine S02_SyncFastTransferMessage_SlicedModel() : Actions
{
	S02_SyncFastTransferMessage_Scenario()
	||
    (construct model program from SyncFastTransferMessage where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S01_SyncFastTransferMessage_TestSuite machine.
machine S02_SyncFastTransferMessage_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S02_SyncFastTransferMessage_SlicedModel
}

// Configure for normal message in Scenario S02_SyncFastTransferMessageProperties
config SyncFastTransferMessagePropertiesProperties : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.BestBody, CopyToCopyFlags.Move, CopyToCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);    
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.None);       
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyMessages(int serverId, int sourceHandleIndex, RopFastTransferSourceCopyMessagesCopyFlags copyFlag, SendOptionAlls option,Sequence<int> messageIds, out int copyMessageHandleIndex)
    where{.
        Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyFlag,RopFastTransferSourceCopyMessagesCopyFlags.BestBody, RopFastTransferSourceCopyMessagesCopyFlags.SendEntryId,RopFastTransferSourceCopyMessagesCopyFlags.Move );
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.ForceUnicode);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};
}

//This machine is designed to define the operation sequencing for FastTransfer download message operation.
//constraint value to parameters for testing
machine S02_SyncFastTransferMessageProperties_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageHandleIndex,
        int messageIdIndex,
        int attachmentHandleIndex,
        int messageDownloadHandleIndex,
        int transferBufferIndex,
        Sequence<string> PropertyTags,
        Sequence<string> SetPropertyTags,
        Sequence<int> messageIds
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagFolderId").Add("PidTagComment").Add("PidTagDisplayName").Add("PidTagMessageRecipients").Add("PidTagMessageAttachments").Add("PidTagBody"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(_, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					// Create an message in the Inbox folder
					CreateMessage(_, inboxFolderHandleIndex, inboxFolderIdIndex,false, out messageHandleIndex);
					SetProperties(_,messageHandleIndex,SetPropertyTags);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex);
					// Create an attachment for the new created message
					CreateAttachment(_,messageHandleIndex,out attachmentHandleIndex);
					SaveChangesAttachment(_,attachmentHandleIndex);
					{.
						Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(messageIdIndex));
					.}:
					(
						(
						CheckRequirementEnabled(3442001, out _);
						CheckRequirementEnabled(3442002, out _);
						CheckRequirementEnabled(3442003, out _);
						CheckRequirementEnabled(3442004, out _);
						CheckRequirementEnabled(211501, out _);
						CheckRequirementEnabled(3118003, out _);
						FastTransferSourceCopyTo(_,messageHandleIndex,InputHandleType.MessageHandle,true,_,_,PropertyTags,out messageDownloadHandleIndex);)
						|
						(
						CheckRequirementEnabled(3442001, out _);
						CheckRequirementEnabled(3442002, out _);
						CheckRequirementEnabled(3442003, out _);
						CheckRequirementEnabled(3442004, out _);
						CheckRequirementEnabled(211501, out _);
						CheckRequirementEnabled(3118003, out _);
						FastTransferSourceCopyTo(_,messageHandleIndex,InputHandleType.MessageHandle,false,_,_,PropertyTags,out messageDownloadHandleIndex);)
						|
						(CheckRequirementEnabled(3466, out _);
						FastTransferSourceCopyProperties(_,messageHandleIndex,InputHandleType.MessageHandle,_,_,_,PropertyTags,out messageDownloadHandleIndex);)
						|
						(
						CheckRequirementEnabled(2117002, out _);
						CheckRequirementEnabled(211601, out _);
						CheckRequirementEnabled(499003, out _);
						FastTransferSourceCopyMessages(_,inboxFolderHandleIndex,_,_,messageIds, out messageDownloadHandleIndex);)
					);
					FastTransferSourceGetBuffer(1,messageDownloadHandleIndex,BufferSize.Normal,out transferBufferIndex,out _,out _);

					Release(_, messageHandleIndex);
					Release(_, messageDownloadHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S02_SyncFastTransferMessageProperties_Scenario machine.
machine S02_SyncFastTransferMessageProperties_SlicedModel() : Actions
{
	S02_SyncFastTransferMessageProperties_Scenario()
	||
    (construct model program from SyncFastTransferMessagePropertiesProperties where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S02_SyncFastTransferMessageProperties_TestSuite machine.
machine S02_SyncFastTransferMessageProperties_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S02_SyncFastTransferMessageProperties_SlicedModel
}

// This machine is designed to define the operation sequencing for FastTransfer download message operation.
// constraint value to parameters for testing
machine S02_SyncFastTransferMessageWithLargeProperty_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageHandleIndex,
        int messageIdIndex,
        int messageDownloadHandleIndex,
        int transferBufferIndex,
        Sequence<string> SetPropertyTags,
        Sequence<int> messageIds
        where
        {.
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody").Add("PidTagPolicyTag"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					// Create an message in the Inbox folder
					CreateMessage(1, inboxFolderHandleIndex, inboxFolderIdIndex,false, out messageHandleIndex);
					SetProperties(1,messageHandleIndex,SetPropertyTags);
					SaveChangesMessage(1, messageHandleIndex, out messageIdIndex);
					FastTransferSourceCopyProperties(1,messageHandleIndex,InputHandleType.MessageHandle,false,_,_,SetPropertyTags,out messageDownloadHandleIndex);
					(FastTransferSourceGetBuffer(1,messageDownloadHandleIndex,BufferSize.Partial,out transferBufferIndex,out _,out _)|
					FastTransferSourceGetBuffer(1,messageDownloadHandleIndex,BufferSize.NoRoom,out transferBufferIndex,out _,out _)|
					(
					FastTransferSourceGetBuffer(1,messageDownloadHandleIndex,BufferSize.Greater,out transferBufferIndex,out _,out _);
					FastTransferSourceGetBuffer(1,messageDownloadHandleIndex,BufferSize.Greater,out transferBufferIndex,out _,out _);
					) 
					);
		   
					Release(1, messageHandleIndex);
					Release(1, messageDownloadHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S02_SyncFastTransferMessageWithLargeProperty_Scenario machine.
machine S02_SyncFastTransferMessageWithLargeProperty_SlicedModel() : Actions
{
	S02_SyncFastTransferMessageWithLargeProperty_Scenario()
	||
    (construct model program from SyncFastTransferMessagePropertiesProperties where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S02_SyncFastTransferMessageWithLargeProperty_TestSuite machine.
machine S02_SyncFastTransferMessageWithLargeProperty_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S02_SyncFastTransferMessageWithLargeProperty_SlicedModel
}


// Configure for normal message in Scenario S02_SyncFastTransferMessageProperties
config SyncFastTransferMessageWithErrorParameter : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
}

//This machine is designed to define the operation sequencing for FastTransfer download message operation.
machine S02_SyncFastTransferMessageWithErrorParameter_Scenario() : Actions 
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageHandleIndex,
        int messageIdIndex,
        int messageDownloadHandleIndex,
        int transferBufferIndex,
        Sequence<string> SetPropertyTags,
        Sequence<int> messageIds
        where
        {.
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody").Add("PidTagPolicyTag"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					//Create an message in the Inbox folder
					CreateMessage(1, inboxFolderHandleIndex, inboxFolderIdIndex,false, out messageHandleIndex);
					SetProperties(1,messageHandleIndex,SetPropertyTags);
					SaveChangesMessage(1, messageHandleIndex, out messageIdIndex);
					call CheckRequirementEnabled(3470, out _);
					(
						return CheckRequirementEnabled(3470, out false);
						|
						return CheckRequirementEnabled(3470, out true);
						FastTransferSourceCopyProperties(1,messageHandleIndex,InputHandleType.MessageHandle,false, CopyPropertiesCopyFlags.None, SendOptionAlls.Invalid,SetPropertyTags,out messageDownloadHandleIndex);
						FastTransferSourceGetBuffer(1,messageDownloadHandleIndex,BufferSize.Normal,out transferBufferIndex,out _,out _);
						Release(1, messageDownloadHandleIndex);
					)
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S02_SyncFastTransferMessageWithErrorParameter_Scenario machine.
machine S02_SyncFastTransferMessageWithErrorParameter_SlicedModel() : Actions
{
	S02_SyncFastTransferMessageWithErrorParameter_Scenario()
	||
    (construct model program from SyncFastTransferMessageWithErrorParameter where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S02_SyncFastTransferMessageWithErrorParameter_TestSuite machine.
machine S02_SyncFastTransferMessageWithErrorParameter_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S02_SyncFastTransferMessageWithErrorParameter_SlicedModel
}


// Configure for attachment in Scenario S03_SyncFastTransferAttachment
config SyncFastTransferAttachment : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};
}

// This machine is designed to define the operation sequencing for FastTransfer download Attachment operation.
// constraint value to parameters for testing
machine S03_SyncFastTransferAttachment_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageHandleIndex,
        int messageIdIndex,
        int attachmentDownloadHandleIndex,
        int attachmentHandleIndex,
        Sequence<string> PropertyTags,
        Sequence<string> SetPropertyTags,
        Sequence<int> messageIds
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagDisplayName"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagDisplayName"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(_, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateMessage(_, inboxFolderHandleIndex, inboxFolderIdIndex,false, out messageHandleIndex);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex);
					CreateAttachment(_,messageHandleIndex,out attachmentHandleIndex);
					SetProperties(_,messageHandleIndex,SetPropertyTags);
					SaveChangesAttachment(_,attachmentHandleIndex);
					(
						FastTransferSourceCopyTo(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,_ ,_ ,_,PropertyTags,out attachmentDownloadHandleIndex);
					);
					FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex,BufferSize.Normal,out _,out _,out _);
					Release(_, messageHandleIndex);
					Release(_,attachmentHandleIndex);
					Release(_,attachmentDownloadHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S03_SyncFastTransferAttachment_Scenario machine.
machine S03_SyncFastTransferAttachment_SlicedModel() : Actions
{
	S03_SyncFastTransferAttachment_Scenario()
	||
    (construct model program from SyncFastTransferAttachment where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S03_SyncFastTransferAttachment_TestSuite machine.
machine S03_SyncFastTransferAttachment_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S03_SyncFastTransferAttachment_SlicedModel
}

// Configure for attachment in Scenario S03_SyncFastTransferAttachmentLevel
config SyncFastTransferAttachmentLevel : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex, InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        
        Condition.In<SendOptionAlls>(option,SendOptionAlls.RecoverMode,SendOptionAlls.Unicode,SendOptionAlls.Reserved1,SendOptionAlls.Reserved2);
        Condition.In<CopyToCopyFlags>(copyFlag,CopyToCopyFlags.None);
        Combination.Interaction(option);
        Combination.Interaction(copyFlag);
    .};
}

// This machine is designed to generate test case for S03_SyncFastTransferAttachmentLevel
machine S03_SyncFastTransferAttachmentLevel_Scenario() : Actions
{
    (
        let
        int logonHandleIndex,
        int inboxFolderIdIndex,
        int inboxFolderHandleIndex,
        int messageHandleIndex,
        int messageIdIndex,
        int attachmentDownloadHandleIndex,
        int attachmentDownloadHandleIndex2,
        int attachmentHandleIndex,
        int firstBufferIndex,
        int secondBufferindex,
        CopyToCopyFlags copyFlag,
        CopyPropertiesCopyFlags copyPropertiesFlag,
        Sequence<string> PropertyTags,
        Sequence<string> SetPropertyTags,
        Sequence<int> messageIds
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagDisplayName"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagDisplayName"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					Connect;
					Logon(_, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(_, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateMessage(_, inboxFolderHandleIndex, inboxFolderIdIndex,false, out messageHandleIndex);
					SaveChangesMessage(_, messageHandleIndex, out messageIdIndex);
					CreateAttachment(_,messageHandleIndex,out attachmentHandleIndex);
					SetProperties(_,messageHandleIndex,SetPropertyTags);
					SaveChangesAttachment(_,attachmentHandleIndex);
					(
						(
							FastTransferSourceCopyTo(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,true ,copyFlag ,SendOptionAlls.Unicode,PropertyTags,out attachmentDownloadHandleIndex);
							FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex,BufferSize.Normal,out firstBufferIndex,out _,out _);
							FastTransferSourceCopyTo(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,false,copyFlag ,SendOptionAlls.Unicode,PropertyTags,out attachmentDownloadHandleIndex2);
							FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
							AreEqual(EnumFastTransferOperation.FastTransferSourceCopyTo,firstBufferIndex,secondBufferindex):
							{.
								ModelHelper.CaptureRequirement(369001,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [Level (1 byte)] Reply is the same whether Level field is set or not if InputServerObject is an Attachment object.");
								ModelHelper.CaptureRequirement(370001,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [Level (1 byte)] Reply is the same whether Level field is set or not just as if it is set to 0x00 if the InputServerObject field is an Attachment object.");
							.};
						)
						|
						(
						   FastTransferSourceCopyProperties(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,true, copyPropertiesFlag, SendOptionAlls.Unicode, PropertyTags,out attachmentDownloadHandleIndex);
						   FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex,BufferSize.Normal,out firstBufferIndex,out _,out _);
						   FastTransferSourceCopyProperties(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,false,copyPropertiesFlag ,SendOptionAlls.Unicode,PropertyTags,out attachmentDownloadHandleIndex2);
						   FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
						   AreEqual(EnumFastTransferOperation.FastTransferSourceCopyProperties,firstBufferIndex,secondBufferindex):
						   {.
							   ModelHelper.CaptureRequirement(441001,"[In RopFastTransferSourceCopyProperties ROP Request Buffer] [Level (1 byte)] Server replies the same response for setting 0x00 or 0x01 of Level field if InputServerObject is an Attachment object.");
						   .};
						)
						|
						(
							FastTransferSourceCopyTo(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,true,copyFlag,SendOptionAlls.Reserved1,PropertyTags,out attachmentDownloadHandleIndex);
							FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex,BufferSize.Normal,out firstBufferIndex,out _,out _);
							FastTransferSourceCopyTo(_,attachmentHandleIndex,InputHandleType.AttachmentHandle,true,copyFlag,SendOptionAlls.Reserved2,PropertyTags,out attachmentDownloadHandleIndex2);
							FastTransferSourceGetBuffer(_,attachmentDownloadHandleIndex2,BufferSize.Normal,out secondBufferindex,out _,out _);
							AreEqual(EnumFastTransferOperation.FastTransferSourceCopyTo,firstBufferIndex,secondBufferindex):
						   {.
								ModelHelper.CaptureRequirement(42002,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [SendOptions] [When flag name is Reserved1(0x20)] Reply is the same whether received or not.");
								ModelHelper.CaptureRequirement(42202,"[In RopFastTransferSourceCopyTo ROP Request Buffer] [SendOptions] [When flag name is Reserved2(0x40)] Reply is the same whether received or not.");
						   .};
						)
					);
					Release(_, messageHandleIndex);
					Release(_,attachmentHandleIndex);
					Release(_,attachmentDownloadHandleIndex);
					Release(_,attachmentDownloadHandleIndex2);
					
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
        )
    )
}

// Sliced model based on the S03_SyncFastTransferAttachmentLevel_Scenario machine.
machine S03_SyncFastTransferAttachmentLevel_SlicedModel() : Actions
{
	S03_SyncFastTransferAttachmentLevel_Scenario()
	||
    (construct model program from SyncFastTransferAttachmentLevel where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S03_SyncFastTransferAttachmentLevel_TestSuite machine.
machine S03_SyncFastTransferAttachmentLevel_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S03_SyncFastTransferAttachmentLevel_SlicedModel
}

// Configure for S04_SyncFastTransferServerClientServer
config SyncFastTransferServerClientServer : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1, 2);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferDestinationConfigure(int serverId, int objHandleIndex, SourceOperation option, FastTransferDestinationConfigureCopyFlags copyFlag, out int uploadContextHandleIndex)
    where{.
        Condition.In<FastTransferDestinationConfigureCopyFlags>(copyFlag,FastTransferDestinationConfigureCopyFlags.Move,FastTransferDestinationConfigureCopyFlags.Invalid);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex,InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<CopyToCopyFlags>(copyFlag, CopyToCopyFlags.Move);
        Condition.In<bool>(level,false);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyProperties(int serverId, int sourceHandleIndex,InputHandleType handleType, bool level, CopyPropertiesCopyFlags copyFlag, SendOptionAlls option,Sequence<string> PropertyTags, out int copyPropertiesHandleIndex)
    where{.
        
        Condition.In<CopyPropertiesCopyFlags>(copyFlag,CopyPropertiesCopyFlags.Move);
        Condition.In<bool>(level,false);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyMessages(int serverId, int sourceHandleIndex, RopFastTransferSourceCopyMessagesCopyFlags copyFlag, SendOptionAlls option,Sequence<int> messageIds, out int copyMessageHandleIndex)
    where{.
        Condition.In<RopFastTransferSourceCopyMessagesCopyFlags>(copyFlag,RopFastTransferSourceCopyMessagesCopyFlags.BestBody, RopFastTransferSourceCopyMessagesCopyFlags.Move, RopFastTransferSourceCopyMessagesCopyFlags.SendEntryId );
        
    .};
    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyFolder(int serverId,int sourceHandleIndex,CopyFolderCopyFlags copyFlag,SendOptionAlls option,out int copyFolderHandleIndex)
    where{.
        Condition.In<CopyFolderCopyFlags>(copyFlag, CopyFolderCopyFlags.CopySubfolders);
    .};
}

// This machine is designed to define the operation sequencing for Server-to-client-to-server upload operation.
// constraint value to parameters for testing
machine S04_SyncFastTransferServerClientServer_Scenario() : Actions
{
    (
        let
        int logonHandleIndex1,
        int logonHandleIndex2,
        int inboxFolderIdIndex1,
        int inboxFolderIdIndex2,
        int inboxFolderHandleIndex1,
        int inboxFolderHandleIndex2,
        // Variables for new folder and message in serverA
        int serverANewFolderIdIndex,
        int serverANewFolderHandleIndex,
        int serverBNewFolderIdIndex,
        int serverBNewFolderHandleIndex,
        // Variables for new folder and message in serverB
        int serverAMessageHandleIndex,
        int serverAMessageIdIndex,
        int serverBMessageHandleIndex,
        int serverBMessageIdIndex,
        int serverAattachmentHandleIndex,
        int serverBattachmentHandleIndex,
        int DownloadHandleIndex,
        int configHandleIndex,
        int transferBufferIndex,
        Sequence<int> messageIds,
        Sequence<string> SetPropertyTags,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagBody").Add("PidTagCreationTime"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					call CheckSecondSUTOnline(out _);
					(
					   return CheckSecondSUTOnline(out false);
					   |
					   (
							return CheckSecondSUTOnline(out true);
							Connect(1, _);
							Connect(2, _);
							Logon(1, _, out logonHandleIndex1, out inboxFolderIdIndex1);
							Logon(2, _, out logonHandleIndex2, out inboxFolderIdIndex2);
							OpenFolder(1, logonHandleIndex1, inboxFolderIdIndex1, out inboxFolderHandleIndex1);
							OpenFolder(2, logonHandleIndex2, inboxFolderIdIndex2, out inboxFolderHandleIndex2);
							//Create a new folder in serverA and serverB
							CreateFolder(1,inboxFolderHandleIndex1,"TestFolderInServerA",out serverANewFolderIdIndex,out serverANewFolderHandleIndex);
							CreateFolder(1,serverANewFolderHandleIndex,"SubFolderServerA",out _,out _);
							CreateFolder(2,inboxFolderHandleIndex2,"TestFolderInServerB",out serverBNewFolderIdIndex,out serverBNewFolderHandleIndex);
							//Create a new message in serverA and serverB
							CreateMessage(1, serverANewFolderHandleIndex, serverANewFolderIdIndex, false, out serverAMessageHandleIndex);
							SetProperties(_,serverAMessageHandleIndex,SetPropertyTags);
							SaveChangesMessage(1, serverAMessageHandleIndex, out serverAMessageIdIndex);
							{.
								Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(serverAMessageIdIndex));
							.}:
							CreateMessage(2, serverBNewFolderHandleIndex, serverBNewFolderIdIndex, false, out serverBMessageHandleIndex);
							SaveChangesMessage(2, serverBMessageHandleIndex, out serverBMessageIdIndex);
							//Create an attacnment for the new created message
							CreateAttachment(1,serverAMessageHandleIndex,out serverAattachmentHandleIndex);
							SaveChangesAttachment(1,serverAattachmentHandleIndex);
							CreateAttachment(2,serverBMessageHandleIndex,out serverBattachmentHandleIndex);
							SaveChangesAttachment(2,serverBattachmentHandleIndex);
							(
								(
									CheckRequirementEnabled(3442001, out _);
									FastTransferSourceCopyTo(1,serverANewFolderHandleIndex,InputHandleType.FolderHandle,_ ,_,SendOptionAlls.ForUpload,PropertyTags,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBNewFolderHandleIndex,SourceOperation.CopyTo,_,out configHandleIndex);
								)|
								(
									CheckRequirementEnabled(3454, out _);
									CheckRequirementEnabled(3442001, out _);
									FastTransferSourceCopyTo(1,serverAMessageHandleIndex,InputHandleType.MessageHandle,_ ,_,SendOptionAlls.ForUpload,PropertyTags,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBMessageHandleIndex,SourceOperation.CopyTo,_,out configHandleIndex);
								)|
								(
									CheckRequirementEnabled(3466, out _);
									FastTransferSourceCopyProperties(1,serverANewFolderHandleIndex,InputHandleType.FolderHandle,_,_,SendOptionAlls.ForUpload,PropertyTags,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBNewFolderHandleIndex,SourceOperation.CopyProperties,_,out configHandleIndex);
								)|
								(
									CheckRequirementEnabled(3466, out _);
									FastTransferSourceCopyProperties(1,serverAMessageHandleIndex,InputHandleType.MessageHandle,_,_,SendOptionAlls.ForUpload,PropertyTags,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBMessageHandleIndex,SourceOperation.CopyProperties,_,out configHandleIndex);
								)|
								(
									FastTransferSourceCopyMessages(1,serverANewFolderHandleIndex,_,SendOptionAlls.ForUpload,messageIds, out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBNewFolderHandleIndex,SourceOperation.CopyMessages,_,out configHandleIndex);
								)|
								(
									FastTransferSourceCopyFolder(1,serverANewFolderHandleIndex,_,SendOptionAlls.ForUpload,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBNewFolderHandleIndex,SourceOperation.CopyFolder,_,out configHandleIndex);
								)|
								(
									FastTransferSourceCopyFolder(1,serverANewFolderHandleIndex,_,SendOptionAlls.ForUpload,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBNewFolderHandleIndex,SourceOperation.CopyFolder,_,out configHandleIndex);
								)
								|
								(
									CheckRequirementEnabled(3442001, out _);
									FastTransferSourceCopyTo(1,serverAattachmentHandleIndex,InputHandleType.AttachmentHandle,_ ,_,SendOptionAlls.ForUpload,PropertyTags,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBattachmentHandleIndex,SourceOperation.CopyTo,_,out configHandleIndex);
								)
								|
								(
									CheckRequirementEnabled(3466, out _);
									FastTransferSourceCopyProperties(1,serverAattachmentHandleIndex,InputHandleType.AttachmentHandle,_,_,SendOptionAlls.ForUpload,PropertyTags,out DownloadHandleIndex);
									CheckRequirementEnabled(3492001, out _);
									CheckRequirementEnabled(3492002, out _);
									FastTransferDestinationConfigure(2,serverBattachmentHandleIndex,SourceOperation.CopyProperties,_,out configHandleIndex);
								);           
							);

							TellVersion(1,DownloadHandleIndex,2);
							TellVersion(2,configHandleIndex,1);

							FastTransferSourceGetBuffer(1,DownloadHandleIndex,BufferSize.Normal,out transferBufferIndex,out _,out _);
							FastTransferDestinationPutBuffer(2,configHandleIndex,transferBufferIndex);

							Release(1,serverAMessageHandleIndex);
							Release(2,serverBMessageHandleIndex);
							Release(1,serverAMessageHandleIndex);
							Release(1,serverAattachmentHandleIndex);
							Release(2,serverBattachmentHandleIndex);
							Release(2,configHandleIndex);
						)
					)
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
            );
        )
    )
}

// Sliced model based on the S04_SyncFastTransferServerClientServer_Scenario machine.
machine S04_SyncFastTransferServerClientServer_SlicedModel() : Actions
{
	S04_SyncFastTransferServerClientServer_Scenario()
	||
    (construct model program from SyncFastTransferServerClientServer where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S04_SyncFastTransferServerClientServer_TestSuite machine.
machine S04_SyncFastTransferServerClientServer_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S04_SyncFastTransferServerClientServer_SlicedModel
}

// Configure for S04_SyncFastTransferServerClientServerUsecpid
config SyncFastTransferServerClientServerUsecpid : Actions
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1, 2);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferDestinationConfigure(int serverId, int objHandleIndex, SourceOperation option, FastTransferDestinationConfigureCopyFlags copyFlag, out int uploadContextHandleIndex)
    where{.
        Condition.In<FastTransferDestinationConfigureCopyFlags>(copyFlag,FastTransferDestinationConfigureCopyFlags.Move);
    .};

    action RopResult IMS_OXCFXICSAdapter.FastTransferSourceCopyTo(int serverId, int sourceHandleIndex,InputHandleType handleType, bool level, CopyToCopyFlags copyFlag, SendOptionAlls option, Sequence<string> PropertyTags, out int copyToHandleIndex)
    where{.
        Condition.In<CopyToCopyFlags>(copyFlag, CopyToCopyFlags.None);
        Condition.In<SendOptionAlls>(option,SendOptionAlls.UseCpid, SendOptionAlls.UseCpid|SendOptionAlls.Unicode,SendOptionAlls.UseCpid|SendOptionAlls.ForceUnicode, SendOptionAlls.UseCpid|SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode); 
        Condition.In<bool>(level,false);
    .};
}

// This machine is designed to define the operation sequencing for Server-to-client-to-server upload operation.
// constraint value to parameters for testing
machine S04_SyncFastTransferServerClientServerUsecpid_Scenario() : Actions
{
    (
        let
        int logonHandleIndex1,
        int logonHandleIndex2,
        int inboxFolderIdIndex1,
        int inboxFolderIdIndex2,
        int inboxFolderHandleIndex1,
        int inboxFolderHandleIndex2,
        //Variables for new folder and message in serverA
        int serverANewFolderIdIndex,
        int serverANewFolderHandleIndex,
        int serverBNewFolderIdIndex,
        int serverBNewFolderHandleIndex,
        //Variables for new folder and message in serverB
        int serverAMessageHandleIndex,
        int serverAMessageIdIndex,
        int serverBMessageHandleIndex,
        int serverBMessageIdIndex,
        int serverAattachmentHandleIndex,
        int serverBattachmentHandleIndex,
        int DownloadHandleIndex,
        int configHandleIndex,
        int transferBufferIndex,
        Sequence<int> messageIds,
        SendOptionAlls sendOption,
        Sequence<string> SetPropertyTags,
        Sequence<string> PropertyTags
        where
        {.
            Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagBody").Add("PidTagCreationTime"));
            Condition.In<Sequence<string>>(SetPropertyTags,(new Sequence<string>()).Add("PidTagBody"));
        .}
        in
        (
			call CheckMAPIHTTPTransportSupported(out _);
            (
				(
					return CheckMAPIHTTPTransportSupported(out true);
					call CheckSecondSUTOnline(out _);
					(
						return CheckSecondSUTOnline(out false);|
						(
							return CheckSecondSUTOnline(out true);
							Connect(1, _);
							Connect(2, _);
							Logon(1, _, out logonHandleIndex1, out inboxFolderIdIndex1);
							Logon(2, _, out logonHandleIndex2, out inboxFolderIdIndex2);
							OpenFolder(1, logonHandleIndex1, inboxFolderIdIndex1, out inboxFolderHandleIndex1);
							OpenFolder(2, logonHandleIndex2, inboxFolderIdIndex2, out inboxFolderHandleIndex2);
							//Create a new folder in serverA and serverB
							CreateFolder(1,inboxFolderHandleIndex1,"TestFolderInServerA",out serverANewFolderIdIndex,out serverANewFolderHandleIndex);
							CreateFolder(1,serverANewFolderHandleIndex,"SubFolderServerA",out _,out _);
							CreateFolder(2,inboxFolderHandleIndex2,"TestFolderInServerB",out serverBNewFolderIdIndex,out serverBNewFolderHandleIndex);
							//Create a new message in serverA and serverB
							CreateMessage(1, serverANewFolderHandleIndex, serverANewFolderIdIndex, false, out serverAMessageHandleIndex);
							SetProperties(_,serverAMessageHandleIndex,SetPropertyTags);
							SaveChangesMessage(1, serverAMessageHandleIndex, out serverAMessageIdIndex);
							{.
								Condition.In<Sequence<int>>(messageIds,(new Sequence<int>()).Add(serverAMessageIdIndex));
							.}:
							CreateMessage(2, serverBNewFolderHandleIndex, serverBNewFolderIdIndex, false, out serverBMessageHandleIndex);
							SaveChangesMessage(2, serverBMessageHandleIndex, out serverBMessageIdIndex);
							//Create an attacnment for the new created message
							CreateAttachment(1,serverAMessageHandleIndex,out serverAattachmentHandleIndex);
							SaveChangesAttachment(1,serverAattachmentHandleIndex);
							CreateAttachment(2,serverBMessageHandleIndex,out serverBattachmentHandleIndex);
							SaveChangesAttachment(2,serverBattachmentHandleIndex);
							CheckRequirementEnabled(3454, out _);
							(            
								(
									FastTransferSourceCopyTo(1,serverAMessageHandleIndex,InputHandleType.MessageHandle,_ ,_,_,PropertyTags,out DownloadHandleIndex);
									FastTransferDestinationConfigure(2,serverBMessageHandleIndex,SourceOperation.CopyTo,_,out configHandleIndex);
								);
							);

							TellVersion(1,DownloadHandleIndex,2);
							TellVersion(2,configHandleIndex,1);

							FastTransferSourceGetBuffer(1,DownloadHandleIndex,BufferSize.Normal,out transferBufferIndex,out _,out _);
							FastTransferDestinationPutBuffer(2,configHandleIndex,transferBufferIndex);

							Release(1,serverAMessageHandleIndex);
							Release(2,serverBMessageHandleIndex);
							Release(1,serverAMessageHandleIndex);
							Release(1,serverAattachmentHandleIndex);
							Release(2,serverBattachmentHandleIndex);
							Release(2,configHandleIndex);
						)
					)
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
		)
    )
}

// Sliced model based on the S04_SyncFastTransferServerClientServerUsecpid_Scenario machine.
machine S04_SyncFastTransferServerClientServerUsecpid_SlicedModel() : Actions
{
	S04_SyncFastTransferServerClientServerUsecpid_Scenario()
	||
    (construct model program from SyncFastTransferServerClientServerUsecpid where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S04_SyncFastTransferServerClientServerUsecpid_TestSuite machine.
machine S04_SyncFastTransferServerClientServerUsecpid_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S04_SyncFastTransferServerClientServerUsecpid_SlicedModel
}

// Configure for ICS Invalid parameter
config ICSInvalidConfig : Actions 
{
    action void IMS_OXCFXICSAdapter.Connect(int serverId, ConnectionType connectionType)
    where
    {.
        Condition.In<int>(serverId, 1, 2);
        Condition.In<ConnectionType>(connectionType, ConnectionType.PrivateMailboxServer);
    .};
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};

      action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)0x10);
    .};

}

// This machine is designed to define the operation sequencing for folder object.
// constraint value to invalid parameters for testing
machine S05_SyncICSHierarchyInvalid_Scenario() : Actions
{
    (
		let
		// The data used in this machine
		Sequence<string> propertyname,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<Sequence<string>>(propertyname, (new Sequence<string>()).Add("PidTagAttachLongFilename"));
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					// precondition operations
					Connect(1, _);
					Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					// protocol operations InvalidParameter
					GetLocalReplicaIds(1, logonHandleIndex, 3);
					(
						(
							CheckRequirementEnabled(2695, out _); // Modify the logical 
							SynchronizationConfigure(1, folderHandleIndex, SynchronizationTypes.InvalidParameter, SendOptionAlls.Unicode, SynchronizationFlag.Unicode, SynchronizationExtraFlag.Eid,propertyname, out downloadcontextHandleIndex);
						)
						|
						SynchronizationConfigure(1, folderHandleIndex, SynchronizationTypes.Hierarchy, SendOptionAlls.Unicode, SynchronizationFlag.Reserved, SynchronizationExtraFlag.Eid,propertyname, out downloadcontextHandleIndex);
						|
						SynchronizationConfigure(1, folderHandleIndex, SynchronizationTypes.Hierarchy, SendOptionAlls.UseCpid, SynchronizationFlag.None, SynchronizationExtraFlag.Eid,propertyname, out downloadcontextHandleIndex);
						|
						(
							CheckRequirementEnabled(3463, out _);
							SynchronizationConfigure(1, folderHandleIndex, SynchronizationTypes.Hierarchy, SendOptionAlls.Invalid, SynchronizationFlag.None, SynchronizationExtraFlag.Eid,propertyname, out downloadcontextHandleIndex);
						)
					);
					DeleteFolder(1, inboxFolderHandleIndex, folderIdIndex);
					Release(1, folderHandleIndex);
					Release(1, downloadcontextHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
		)
    )
}

// Sliced model based on the S05_SyncICSHierarchyInvalid_Scenario machine.
machine S05_SyncICSHierarchyInvalid_SlicedModel() : Actions
{
	S05_SyncICSHierarchyInvalid_Scenario()
	||
    (construct model program from ICSInvalidConfig where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S05_SyncICSHierarchyInvalid_TestSuite machine.
machine S05_SyncICSHierarchyInvalid_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S05_SyncICSHierarchyInvalid_SlicedModel
}

// This machine is designed to  invalid parameters of ICS contents for testing.
// constraint value to invalid parameters for testing
machine S06_SyncICSContentsInvalid_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		string folderName2,
		int folderIdIndex2,
		int folderHandleIndex2,
		int folderHandleIndex3,
		int messageHandleIndex,
		Sequence<int> ImportDeleteMessageIds,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2
		where
		{.
			Condition.In<string>(folderName, "test");
			Condition.In<string>(folderName2, "test2");
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					// Complete the precondition for invalid parameter verification..
					Connect(1, _);
					Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					CreateFolder(1, inboxFolderHandleIndex, folderName2, out folderIdIndex2, out folderHandleIndex2);
					{.
						Condition.In<Sequence<int>>(ImportDeleteMessageIds,(new Sequence<int>()).Add(folderIdIndex2));
					.}:
					GetLocalReplicaIds(1, logonHandleIndex, 3);
					// Implement Upload context and invalid parameter verification.
					SynchronizationOpenCollector(1,folderHandleIndex2, SynchronizationTypes.Contents, out uploadcontextHandleIndex);
					(
						CheckRequirementEnabled(2254001, out _); 
						CheckRequirementEnabled(2593, out _); 
						SynchronizationImportDeletes(1,uploadcontextHandleIndex,ImportDeleteMessageIds,_);
						call CheckRequirementEnabled(35121, out _);
						(
							return CheckRequirementEnabled(35121, out true);
							OpenFolder(1, logonHandleIndex, folderIdIndex2, out folderHandleIndex3):
							{.
								ModelHelper.CaptureRequirement(35121,@"[In Receiving a RopSynchronizationImportDeletes Request] Implementation does fail the ROP before performing any deletions, as opposed to partially completing the ROP, if a deletion will not succeed. (Microsoft Exchange Server 2007 and above follow this behavior.)");
							.};
							|
							return CheckRequirementEnabled(35121, out false);
						)
						|
						(
							CheckRequirementEnabled(3509001, out _);
							CheckRequirementEnabled(350900201, out _);
							SynchronizationImportMessageChange(1, uploadcontextHandleIndex,0,ImportFlag.InvalidParameter, out messageHandleIndex);
						)
						|
						(
							SynchronizationImportMessageChange(1, uploadcontextHandleIndex,0,ImportFlag.Normal, out messageHandleIndex);
							SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
							SynchronizationOpenCollector(1,folderHandleIndex, SynchronizationTypes.Contents, out uploadcontextHandleIndex2);
							SynchronizationImportMessageMove(1,uploadcontextHandleIndex2, folderIdIndex2, folderIdIndex, messageIdIndex,folderHandleIndex2, folderHandleIndex, true, out _, out _);
							Release(1, uploadcontextHandleIndex2);
						)
					);
					Release(1, uploadcontextHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S06_SyncICSContentsInvalid_Scenario machine.
machine S06_SyncICSContentsInvalid_SlicedModel() : Actions
{
	S06_SyncICSContentsInvalid_Scenario()
	||
    (construct model program from ICSInvalidConfig where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsInvalid_TestSuite machine.
machine S06_SyncICSContentsInvalid_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsInvalid_SlicedModel
}

// Configure for scenario S05_SyncICSHierarchyDelete
config SyncICSHierarchyDelete : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.NoForeignIdentifiers,SynchronizationFlag.Unicode|SynchronizationFlag.NoDeletions|SynchronizationFlag.NoForeignIdentifiers);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag,SynchronizationExtraFlag.Eid,0x00);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagAttachLongFilename"));
        Combination.Pairwise(option, synchronizationFlag, synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)ImportDeleteFlags.Hierarchy);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(1).Add(2));
    .};
}

// This machine is designed to define the operation sequencing for folder object.
// constraint value to deletions of Hierarchy sync for testing
machine S05_SyncICSHierarchyDelete_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		Sequence<int> ImportDeleteFolderIds,
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		Set<string> properties,
		int deleteFolderId,
		string folderName,
		AbstractFastTransferStream fastTransferStream,
		int ICSStateIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int downloadcontextHandleIndex2,
		int StateHandleIndex
		where
		{.
			Condition.In<string>(folderName, "test");
			Condition.In<Set<string>>(properties, (new Set<string>()).Add("PidTagFolderType"));
			Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download deletion of Hierarchy sync
					 CheckRequirementEnabled(2652 ,out _);
					 CheckRequirementEnabled(1062 ,out _);
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex);
					 SynchronizationImportHierarchyChange(1, uploadcontextHandleIndex,folderHandleIndex, properties, 0, out deleteFolderId);
					 {.
						 Condition.In<Sequence<int>>(ImportDeleteFolderIds,(new Sequence<int>()).Add(deleteFolderId));
					 .}:
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen, false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _,out fastTransferStream,out _);
					 {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractHierarchySync.FinalICSState.AbstractICSStateIndex);
					 .}:
					 SynchronizationImportDeletes(1,uploadcontextHandleIndex,ImportDeleteFolderIds,_);
					  // Implement download deletion of Hierarchy sync in download context
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen, false, ICSStateIndex);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex);
					 Release(1, uploadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S05_SyncICSHierarchyDelete_Scenario machine.
machine S05_SyncICSHierarchyDelete_SlicedModel() : Actions
{
	S05_SyncICSHierarchyDelete_Scenario()
	||
    (construct model program from SyncICSHierarchyDelete where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S05_SyncICSHierarchyDelete_TestSuite machine.
machine S05_SyncICSHierarchyDelete_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S05_SyncICSHierarchyDelete_SlicedModel
}

//Config for scenario S05_SyncICSHierarchyDeleteCheck
config SyncICSHierarchyDeleteCheck : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.NoForeignIdentifiers);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag,SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagAttachLongFilename"));
        Combination.Pairwise(option, synchronizationFlag, synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)(ImportDeleteFlags.Hierarchy|ImportDeleteFlags.HardDelete));
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(1).Add(2));
    .};
}

//This machine is designed to define the operation sequencing for folder object.
//constraint value to deletions of Hierarchysync for testing
machine S05_SyncICSHierarchyDeleteCheck_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		Sequence<int> ImportDeleteFolderIds,
		Sequence<int> ImportDeleteFolderIdsHardDelete,
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		Set<string> properties,
		int deleteFolderId,
		int deleteFolderIdHardDelete,
		string folderName,
		AbstractFastTransferStream fastTransferStream,
		int ICSStateIndex,
		int uploadcontextHandleIndex,
		int uploadcontextHandleIndexHardDelete,
		int downloadcontextHandleIndex,
		int downloadcontextHandleIndex2,
		int StateHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<Set<string>>(properties, (new Set<string>()).Add("PidTagFolderType"));
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 //Complete the precondition for download deletion of Hierarchysync
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex);
					 SynchronizationImportHierarchyChange(1, uploadcontextHandleIndex,folderHandleIndex, properties, 0, out deleteFolderId);
					 {.
						 Condition.In<Sequence<int>>(ImportDeleteFolderIds,(new Sequence<int>()).Add(deleteFolderId));
					 .}:
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen, false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _,out fastTransferStream,out _);
					 {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractHierarchySync.FinalICSState.AbstractICSStateIndex);
					 .}:
					 GetHierarchyTable(1,folderHandleIndex,DeleteFlags.Initial,out _);
					 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndexHardDelete);
					 CheckRequirementEnabled(2593, out _); // Modify the logical
					 SynchronizationImportDeletes(1,uploadcontextHandleIndex,ImportDeleteFolderIds,_);
					  //Implement download deletion of Hierarchysync in download context
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen, false, ICSStateIndex);
					 CheckRequirementEnabled(2652, out _); 
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
					 CheckRequirementEnabled(90205002,out _);
					 GetHierarchyTable(1,folderHandleIndex,DeleteFlags.HardDeleteCheck,out _);
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, uploadcontextHandleIndexHardDelete);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S05_SyncICSHierarchyDeleteCheck_Scenario machine.
machine S05_SyncICSHierarchyDeleteCheck_SlicedModel() : Actions
{
	S05_SyncICSHierarchyDeleteCheck_Scenario()
	||
    (construct model program from SyncICSHierarchyDeleteCheck where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S05_SyncICSHierarchyDeleteCheck_TestSuite machine.
machine S05_SyncICSHierarchyDeleteCheck_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S05_SyncICSHierarchyDeleteCheck_SlicedModel
}


//Config for scenario S05_Sync_ICS_Hierarchy
config SyncICSHierarchyChange : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.NoForeignIdentifiers,SynchronizationFlag.Unicode|SynchronizationFlag.NoDeletions|SynchronizationFlag.NoForeignIdentifiers);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag,SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagAttachLongFilename"));
        Combination.Pairwise(option, synchronizationFlag, synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(1).Add(2));
    .};
}

//This machine is designed to define the operation sequencing for folder object.
//constraint value to folderchange of Hierarchysync  for testing
machine S05_SyncICSHierarchyChange_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		Set<string> properties,
		int folderIdIndex2,
		int folderHandleIndex2,
		int folderIdIndex3,
		int folderHandleIndex3,
		string folderName,
		string folderName2,
		string folderName3,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<string>(folderName2, "test2");
			 Condition.In<string>(folderName3, "test3");
			 Condition.In<Set<string>>(properties, (new Set<string>()).Add("PidTagFolderType"));
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download folder change of Hierarchy sync
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(1, folderHandleIndex, folderName2, out folderIdIndex2, out folderHandleIndex2);
					 CreateFolder(1, folderHandleIndex2, folderName3, out folderIdIndex3, out folderHandleIndex3);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex);
					 SynchronizationImportHierarchyChange(1, uploadcontextHandleIndex, folderHandleIndex, properties, 0, out _);
					 // Implement download folder change in download context
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen, false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _,out _,out _);
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, downloadcontextHandleIndex);
					 Release(1, uploadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S05_SyncICSHierarchyChange_Scenario machine.
machine S05_SyncICSHierarchyChange_SlicedModel() : Actions
{
	S05_SyncICSHierarchyChange_Scenario()
	||
    (construct model program from SyncICSHierarchyChange where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S05_SyncICSHierarchyChange_TestSuite machine.
machine S05_SyncICSHierarchyChange_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S05_SyncICSHierarchyChange_SlicedModel
}


// Configure for machine S05_SyncICSHierarchyStreamSplit
config SyncICSHierarchyStreamSplit : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.NoForeignIdentifiers);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
    .};
}

//This machine is designed to define the operation sequencing for stream split.
machine S05_SyncICSHierarchyStreamSplit_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download hierarchy
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(1, folderHandleIndex, folderName, out _, out _){60};// Create 60 subfolders under top folder.
					 // Implement download large stream in download context
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen, false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _,out _,out _);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S05_SyncICSHierarchyStreamSplit_Scenario machine.
machine S05_SyncICSHierarchyStreamSplit_SlicedModel() : Actions
{
	S05_SyncICSHierarchyStreamSplit_Scenario()
	||
    (construct model program from SyncICSHierarchyStreamSplit where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S05_SyncICSHierarchyStreamSplit_TestSuite machine.
machine S05_SyncICSHierarchyStreamSplit_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S05_SyncICSHierarchyStreamSplit_SlicedModel
}


//Config for scenario S05_Sync_ICS_Hierarchy
config SyncICSHierarchyImportErrorCode : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.NoForeignIdentifiers);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag,SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagAttachLongFilename"));
        Combination.Pairwise(option, synchronizationFlag, synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(1).Add(2));
    .};
}

//This machine is designed to define the operation sequencing for folder object.
//constraint value to folderchange of Hierarchysync  for testing
machine S05_SyncICSHierarchyImportErrorCode_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		int folderIdIndex1,
		int folderHandleIndex1,
		Set<string> properties,
		string folderName,
		string folderName1,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<string>(folderName1, "test1");
			 Condition.In<Set<string>>(properties, (new Set<string>()).Add("PidTagFolderType"));
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download folder change of Hierarchy sync
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(1, folderHandleIndex, folderName1, out folderIdIndex1, out folderHandleIndex1);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex1,_, out uploadcontextHandleIndex);
					 SynchronizationImportHierarchyChange(1, uploadcontextHandleIndex, -1, properties, 0, out _);
					 Release(1, uploadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S05_SyncICSHierarchyImportErrorCode_Scenario machine.
machine S05_SyncICSHierarchyImportErrorCode_SlicedModel() : Actions
{
	S05_SyncICSHierarchyImportErrorCode_Scenario()
	||
    (construct model program from SyncICSHierarchyImportErrorCode where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S05_SyncICSHierarchyImportErrorCode_TestSuite machine.
machine S05_SyncICSHierarchyImportErrorCode_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S05_SyncICSHierarchyImportErrorCode_SlicedModel
}

// Configure for machine S06_SyncICSContentsNormal
config SyncICSContentsNormal : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode|SendOptionAlls.PartialItem);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal,SynchronizationFlag.Unicode|SynchronizationFlag.ReadState,SynchronizationFlag.Unicode|SynchronizationFlag.Normal|SynchronizationFlag.NoDeletions|SynchronizationFlag.IgnoreNoLongerInScope|SynchronizationFlag.ReadState|SynchronizationFlag.OnlySpecifiedProperties|SynchronizationFlag.BestBody|SynchronizationFlag.NoForeignIdentifiers|SynchronizationFlag.Progress);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid,SynchronizationExtraFlag.CN,SynchronizationExtraFlag.OrderByDeliveryTime,SynchronizationExtraFlag.MessageSize);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

// This machine is designed to define the operation sequencing for normal object.
// constraint value to Normal message for testing
machine S06_SyncICSContentsNormal_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);

		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download normal message
					 CheckRequirementEnabled(2675, out _);
					 CheckRequirementEnabled(2657, out _);
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 // Implement download normal message in download context
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 CheckRequirementEnabled(1193, out _);
					 CheckRequirementEnabled(2665, out _);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
			);
		)
   )
}

// Sliced model based on the S06_SyncICSContentsNormal_Scenario machine.
machine S06_SyncICSContentsNormal_SlicedModel() : Actions
{
	S06_SyncICSContentsNormal_Scenario()
	||
    (construct model program from SyncICSContentsNormal where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsNormal_TestSuite machine.
machine S06_SyncICSContentsNormal_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsNormal_SlicedModel
}


// Configure for machine S06_Sync_ICS_Contents_Normal
config SyncICSContentsPartialItem : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode|SendOptionAlls.PartialItem);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

// This machine is designed to define the operation sequencing for normal object.
// constraint value to Normal message for testing
machine S06_SyncICSContentsPartialItem_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		Sequence<string> propertyTag,
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int ICSStateIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int OpenMessageHandleIndex,
		int messageHandleIndex,
		int messageIdIndex,
		int messageIdIndex2,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		AbstractFastTransferStream fastTransferStream,
		int downloadcontextHandleIndex2
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			  Condition.In<Sequence<string>>(propertyTag, (new Sequence<string>()).Add("PidTagDisplayName"));
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download PartialItem message
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out fastTransferStream,out _);
					  {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
					 .}:
					 OpenMessage(1,folderHandleIndex, folderIdIndex, messageIdIndex, out OpenMessageHandleIndex);
					 SetProperties(1, OpenMessageHandleIndex,propertyTag);
					 SaveChangesMessage(1,OpenMessageHandleIndex, out messageIdIndex2);
					  // Implement download messagechangePartialItem in download context
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, ICSStateIndex);
					 CheckRequirementEnabled(2172, out _);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _, out _,out _);
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex2);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsPartialItem_Scenario machine.
machine S06_SyncICSContentsPartialItem_SlicedModel() : Actions
{
	S06_SyncICSContentsPartialItem_Scenario()
	||
    (construct model program from SyncICSContentsPartialItem where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsPartialItem_TestSuite machine.
machine S06_SyncICSContentsPartialItem_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsPartialItem_SlicedModel
}


//Config for machine S06_Sync_ICS_ContentsFolderChange
config SyncICSContentsFolderChange : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

//This machine is designed to define the operation sequencing for normal object.
//constraint value to Normal message for testing
machine S06_SyncICSContentsFolderChange_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		Sequence<string> propertyTag,
		Sequence<string> propertyTags,
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int ICSStateIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int OpenMessageHandleIndex,
		int messageHandleIndex,
		int messageIdIndex,
		int messageIdIndex2,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		AbstractFastTransferStream fastTransferStream,
		int downloadcontextHandleIndex2
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			 Condition.In<Sequence<string>>(propertyTag, (new Sequence<string>()).Add("PidTagDisplayName"));
			 Condition.In<Sequence<string>>(propertyTags, (new Sequence<string>()).Add("PidTagChangeNumber").Add("PidTagLocalCommitTimeMax"));
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 //Complete the precondition for download PartialItem message
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out fastTransferStream,out _);
					  {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
					 .}:
					 GetPropertiesSpecific(1,folderHandleIndex,propertyTags);
					 OpenMessage(1,folderHandleIndex, folderIdIndex, messageIdIndex, out OpenMessageHandleIndex);
					 SetProperties(1, OpenMessageHandleIndex,propertyTag);
					 SaveChangesMessage(1,OpenMessageHandleIndex, out messageIdIndex2);
					 GetPropertiesSpecific(1,folderHandleIndex,propertyTags);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsFolderChange_Scenario machine.
machine S06_SyncICSContentsFolderChange_SlicedModel() : Actions
{
	S06_SyncICSContentsFolderChange_Scenario()
	||
    (construct model program from SyncICSContentsFolderChange where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsFolderChange_TestSuite machine.
machine S06_SyncICSContentsFolderChange_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsFolderChange_SlicedModel
}



//Config for machine S06_SyncICSContentsRTF
config SyncICSContentsRTF : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetProperties(int serverId, int handleindex, Sequence<string> taggedPropertyValueArray)
    where
    {.
        Condition.In<Sequence<string>>(taggedPropertyValueArray, (new Sequence<string>()).Add("PidTagBody"));
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag,SynchronizationFlag.Unicode|SynchronizationFlag.FAI|SynchronizationFlag.NoDeletions|SynchronizationFlag.IgnoreNoLongerInScope);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid|SynchronizationExtraFlag.CN);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagBody"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

//This machine is designed to define the operation sequencing for message object.
//constraint value to parameters for testing RTF format
machine S06_SyncICSContentsRTF_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for RTF format verification.
					 CheckRequirementEnabled(3118002, out _);
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateMessage(1,folderHandleIndex, folderIdIndex, true, out messageHandleIndex);
					 SetProperties(1, messageHandleIndex, _);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 // Implement download the download context.
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 CheckRequirementEnabled(2117002, out _);
					 CheckRequirementEnabled(499001, out _);
					 CheckRequirementEnabled(2182002, out _);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsRTF_Scenario machine.
machine S06_SyncICSContentsRTF_SlicedModel() : Actions
{
	S06_SyncICSContentsRTF_Scenario()
	||
    (construct model program from SyncICSContentsRTF where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsRTF_TestSuite machine.
machine S06_SyncICSContentsRTF_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsRTF_SlicedModel
}

//This machine is designed to define the operation sequencing for message object.
//constraint value to parameters for testing RTF format
machine S06_SyncICSReadStatus_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		int subfolderIdIndex,
		int subfolderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for RTF format verification.
					 CheckRequirementEnabled(3118002, out _);
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(1, folderHandleIndex, folderName, out subfolderIdIndex, out subfolderHandleIndex);

					 CreateMessage(1,subfolderHandleIndex, subfolderIdIndex, true, out messageHandleIndex);
					 SetProperties(1, messageHandleIndex, _);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 ModifyPermissions(1,folderHandleIndex,PermissionLevels.None);

					 SynchronizationOpenCollector(1,subfolderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportReadStateChanges(1,uploadcontextHandleIndex,messageHandleIndex,false);

					call CheckRequirementEnabled(2813, out _);
					(
						(return CheckRequirementEnabled(2813,out true);
						ModifyPermissions(_,folderHandleIndex,PermissionLevels.Owner);)    
						|
						(return CheckRequirementEnabled(2813,out false);)
					); 

					DeleteFolder(1,folderHandleIndex,subfolderIdIndex);
					DeleteFolder(1,inboxFolderHandleIndex,folderIdIndex);
					 //// Implement download the download context.
					 //SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 //CheckRequirementEnabled(2657, out _);
					 //SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 //SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 //SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 //SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 //CheckRequirementEnabled(2117002, out _);
					 //CheckRequirementEnabled(499001, out _);
					 //CheckRequirementEnabled(2182002, out _);
					 //FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 Release(1, uploadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S06_SyncICSReadStatus_Scenario machine.
machine S06_SyncICSReadStatus_SlicedModel() : Actions
{
	S06_SyncICSReadStatus_Scenario()
	||
    (construct model program from SyncICSContentsRTF where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSReadStatus_TestSuite machine.
machine S06_SyncICSReadStatus_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSReadStatus_SlicedModel
}


// Configure for machine S06_SyncICSContentsDeletion
config SyncICSContentsDeletion : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal,SynchronizationFlag.Unicode|SynchronizationFlag.Normal|SynchronizationFlag.NoDeletions|SynchronizationFlag.IgnoreNoLongerInScope);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid|SynchronizationExtraFlag.OrderByDeliveryTime);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)ImportDeleteFlags.HardDelete,(byte)ImportDeleteFlags.delete);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

// This machine is designed to define the operation sequencing for message object.
// constraint value to parameters for testing Deletion in content sync.
machine S06_SyncICSContentsDeletion_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageHandleIndex2,
		int messageIdIndex,
		Sequence<int> ImportDeleteMessageIds,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2,
		int downloadcontextHandleIndex2,
		AbstractFastTransferStream fastTransferStream,
		int ICSStateIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download deletion.
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 {.
						 Condition.In<Sequence<int>>(ImportDeleteMessageIds,(new Sequence<int>()).Add(messageIdIndex));
					 .}:
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex2);
					 SaveChangesMessage(1,messageHandleIndex2, out _);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					  SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out fastTransferStream,out _);
					 {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
					 .}:
					  // Implement download Deletions in download context.
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
					 CheckRequirementEnabled(2593, out _); 
					 SynchronizationImportDeletes(1,uploadcontextHandleIndex2,ImportDeleteMessageIds,_);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, ICSStateIndex);
					 CheckRequirementEnabled(2652, out _); 
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsDeletion_Scenario machine.
machine S06_SyncICSContentsDeletion_SlicedModel() : Actions
{
	S06_SyncICSContentsDeletion_Scenario()
	||
    (construct model program from SyncICSContentsDeletion where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsDeletion_TestSuite machine.
machine S06_SyncICSContentsDeletion_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsDeletion_SlicedModel
}


//Config for machine S06_SyncICSContentsDeletion
config SyncICSContentsDeletionCheck : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)ImportDeleteFlags.HardDelete,(byte)ImportDeleteFlags.delete);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

//This machine is designed to define the operation sequencing for message object.
//constraint value to parameters for testing Deletion in contentsync.
machine S06_SyncICSContentsDeletionCheck_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageHandleIndex2,
		int messageHandleIndexHardDelete,
		int messageIdIndex,
		int messageIdIndexHardDelete,
		Sequence<int> ImportDeleteMessageIds,
		Sequence<int> ImportDeleteMessageIdsHardDelete,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2,
		int uploadcontextHandleIndex3,
		int downloadcontextHandleIndex2,
		int downloadcontextHandleIndex3,
		AbstractFastTransferStream fastTransferStream,
        byte importDeleteFlagFirst,
        byte importDeleteFlagSecond,
		int ICSStateIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
             Condition.In<byte>(importDeleteFlagFirst,(byte)ImportDeleteFlags.delete);
             Condition.In<byte>(importDeleteFlagSecond,(byte)ImportDeleteFlags.HardDelete);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					return CheckMAPIHTTPTransportSupported(out true);
					 //Complete the precondition for download deletion.
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 {.
						 Condition.In<Sequence<int>>(ImportDeleteMessageIds,(new Sequence<int>()).Add(messageIdIndex));
					 .}:
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndexHardDelete);
					 SaveChangesMessage(1,messageHandleIndexHardDelete, out messageIdIndexHardDelete);
					 {.
						 Condition.In<Sequence<int>>(ImportDeleteMessageIdsHardDelete,(new Sequence<int>()).Add(messageIdIndexHardDelete));
					 .}:
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex2);
					 SaveChangesMessage(1,messageHandleIndex2, out _);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out fastTransferStream,out _);
					 {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
					 .}:
					 // Softe delete check
					 GetContentsTable(1,folderHandleIndex,DeleteFlags.Initial,out _);
					  //Implement download Deletions in download context.
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
					 SynchronizationImportDeletes(1,uploadcontextHandleIndex2,ImportDeleteMessageIds,importDeleteFlagFirst);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, ICSStateIndex);
					 CheckRequirementEnabled(2652, out _); 
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
					 GetContentsTable(1,folderHandleIndex,DeleteFlags.SoftDeleteCheck,out _);

					 // Hard delete check
					 GetContentsTable(1,folderHandleIndex,DeleteFlags.Initial,out _);
					  //Implement download Deletions in download context.
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex3);
					 CheckRequirementEnabled(2593, out _); // Modify the logical
					 SynchronizationImportDeletes(1,uploadcontextHandleIndex3,ImportDeleteMessageIdsHardDelete,importDeleteFlagSecond);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex3);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeen,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetRead,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeenFAI,false, ICSStateIndex);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex3,BufferSize.Normal,out _,out _,out _);
					 GetContentsTable(1,folderHandleIndex,DeleteFlags.HardDeleteCheck,out _);

					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
					 Release(1, uploadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, uploadcontextHandleIndex3);
					 Release(1, downloadcontextHandleIndex3);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
			);
		)
	)
}

// Sliced model based on the S06_SyncICSContentsDeletionCheck_Scenario machine.
machine S06_SyncICSContentsDeletionCheck_SlicedModel() : Actions
{
	S06_SyncICSContentsDeletionCheck_Scenario()
	||
    (construct model program from SyncICSContentsDeletionCheck where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsDeletionCheck_TestSuite machine.
machine S06_SyncICSContentsDeletionCheck_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsDeletionCheck_SlicedModel
}


//Config for machine S06_SyncICSContentsFolderChangeNum
config SyncICSContentsFolderChangeNum : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid|SynchronizationExtraFlag.OrderByDeliveryTime);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)ImportDeleteFlags.delete);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

//This machine is designed to define the operation sequencing for message object.
//constraint value to parameters for testing Deletion in contentsync.
machine S06_SyncICSContentsFolderChangeNum_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		Sequence<string> propertyTags,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageHandleIndex2,
		int messageIdIndex,
		Sequence<int> ImportDeleteMessageIds,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2,
		int downloadcontextHandleIndex2,
		AbstractFastTransferStream fastTransferStream,
		int ICSStateIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			  Condition.In<Sequence<string>>(propertyTags, (new Sequence<string>()).Add("PidTagChangeNumber").Add("PidTagDeletedCountTotal"));
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 //Complete the precondition for download deletion.
					 CheckRequirementEnabled(2652,out _);
					 CheckRequirementEnabled(1062,out _);
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 {.
						 Condition.In<Sequence<int>>(ImportDeleteMessageIds,(new Sequence<int>()).Add(messageIdIndex));
					 .}:
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex2);
					 SaveChangesMessage(1,messageHandleIndex2, out _);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					  SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out fastTransferStream,out _);
					 {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
					 .}:
					  //Implement download Deletions in download context.
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
					 SynchronizationImportDeletes(1,uploadcontextHandleIndex2,ImportDeleteMessageIds,_);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, ICSStateIndex);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
					 GetPropertiesSpecific(1,folderHandleIndex,propertyTags);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsFolderChangeNum_Scenario machine.
machine S06_SyncICSContentsFolderChangeNum_SlicedModel() : Actions
{
	S06_SyncICSContentsFolderChangeNum_Scenario()
	||
    (construct model program from SyncICSContentsFolderChangeNum where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsFolderChangeNum_TestSuite machine.
machine S06_SyncICSContentsFolderChangeNum_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsFolderChangeNum_SlicedModel
}


//Config for machine S06_SyncICSContentsReadState
config SyncICSContentsReadState : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal|SynchronizationFlag.ReadState,SynchronizationFlag.None);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(synchronizationFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
}

// This machine is designed to define the operation sequencing for message object.
// constraint value to parameters for testing ReadStatechange in content sync
machine S06_SyncICSContentsUpdateReadStateFail_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		SynchronizationFlag synchronizationFlag,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		int subFolderIdIndex,
		int subFolderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2,
		int downloadcontextHandleIndex2,
		int uploadcontextHandleIndex3,
		int downloadcontextHandleIndex3,
		Sequence<string> propertyTag,
		int ICSStateIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			 Condition.In<Sequence<string>>(propertyTag,new Sequence<string>().Add("PidTagMessageFlags"));
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 //Complete the precondition for download conext for ImportMoveMessage operation.
					 CheckRequirementEnabled(1193, out _);
					 CheckRequirementEnabled(2665, out _);
					 CheckRequirementEnabled(2666, out _);
					 Connect(1, ConnectionType.PublicFolderServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(_,folderHandleIndex,"SubFolder",out subFolderIdIndex,out subFolderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,subFolderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 SynchronizationConfigure(1, subFolderHandleIndex, _,_, SynchronizationFlag.None,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);

					 ModifyPermissions(1,folderHandleIndex,PermissionLevels.None);  

					 //Generate readstatechange in contentsync
					 SynchronizationOpenCollector(1,subFolderHandleIndex, _, out uploadcontextHandleIndex2);
					 SynchronizationImportReadStateChanges(1,uploadcontextHandleIndex2,messageHandleIndex,false);
					 GetPropertiesSpecific(1,messageHandleIndex,propertyTag);
													   
					call CheckRequirementEnabled(2813, out _);
					(
						(return CheckRequirementEnabled(2813,out true);
						ModifyPermissions(_,folderHandleIndex,PermissionLevels.Owner);)    
						|
						(return CheckRequirementEnabled(2813,out false);)
					); 

					DeleteFolder(1,folderHandleIndex,subFolderIdIndex);
					DeleteFolder(1,inboxFolderHandleIndex,folderIdIndex);

					 Release(1, uploadcontextHandleIndex2);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsUpdateReadStateFail_Scenario machine.
machine S06_SyncICSContentsUpdateReadStateFail_SlicedModel() : Actions
{
	S06_SyncICSContentsUpdateReadStateFail_Scenario()
	||
    (construct model program from SyncICSContentsReadState where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsUpdateReadStateFail_TestSuite machine.
machine S06_SyncICSContentsUpdateReadStateFail_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsUpdateReadStateFail_SlicedModel
}

// This machine is designed to define the operation sequencing for message object.
// constraint value to parameters for testing ReadStatechange in content sync
machine S06_SyncICSContentsReadState_Scenario() : Actions
{
	(
		let
		//The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		SynchronizationFlag synchronizationFlag,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2,
		int downloadcontextHandleIndex2,
		int uploadcontextHandleIndex3,
		int downloadcontextHandleIndex3,
		int ICSStateIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 //Complete the precondition for download conext for ImportMoveMessage operation.
					 CheckRequirementEnabled(1193, out _);
					 CheckRequirementEnabled(2665, out _);
					 CheckRequirementEnabled(2666, out _);
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, synchronizationFlag,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 //Generate readstatechange in contentsync
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
					 SynchronizationImportReadStateChanges(1,uploadcontextHandleIndex2,messageHandleIndex,false);
					 //Implement download ReadStateChanges in download context.
					 SynchronizationConfigure(1, folderHandleIndex, _,_, synchronizationFlag,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, 1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, 1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, 1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, 1);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex3);
					 SynchronizationImportReadStateChanges(1,uploadcontextHandleIndex3,messageHandleIndex,true);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, synchronizationFlag,_,_, out downloadcontextHandleIndex3);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagIdsetGiven,true, 1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeen,false, 1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetRead,false, 1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeenFAI,false, 1);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex3,BufferSize.Normal,out _,out _,out _);
					 Release(1, uploadcontextHandleIndex2);
					 Release(1, uploadcontextHandleIndex3);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex3);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsReadState_Scenario machine.
machine S06_SyncICSContentsReadState_SlicedModel() : Actions
{
	S06_SyncICSContentsReadState_Scenario()
	||
    (construct model program from SyncICSContentsReadState where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsReadState_TestSuite machine.
machine S06_SyncICSContentsReadState_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsReadState_SlicedModel
}


// Configure for machine S06_SyncICSContentsMove
config SyncICSContentsMove : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
}

// This machine is designed to define the operation sequencing for folder object.
// constraint value to importMoveMessage for testing
machine S06_SyncICSContentsMove_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		string folderName2,
		int folderIdIndex2,
		int folderHandleIndex2,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<string>(folderName2, "test2");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download context of after import move message operation
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName2, out folderIdIndex2, out folderHandleIndex2);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex2, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 // Implement import move message operation
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
					 SynchronizationImportMessageMove(1,uploadcontextHandleIndex2, folderIdIndex2, folderIdIndex, messageIdIndex,folderHandleIndex2, folderHandleIndex, false, out _, out _);
					 // Implement download content sync in download context.
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 Release(1, uploadcontextHandleIndex2);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsMove_Scenario machine.
machine S06_SyncICSContentsMove_SlicedModel() : Actions
{
	S06_SyncICSContentsMove_Scenario()
	||
    (construct model program from SyncICSContentsMove where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsMove_TestSuite machine.
machine S06_SyncICSContentsMove_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsMove_SlicedModel
}


// Configure for machine S06_SyncICSContentsMove
config SyncICSContentsMoveFAI : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Associated);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.FAI);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
}

// This machine is designed to define the operation sequencing for folder object.
// constraint value to importMoveMessage for testing
machine S06_SyncICSContentsMoveFAI_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		string folderName2,
		int folderIdIndex2,
		int folderHandleIndex2,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex,
		int uploadcontextHandleIndex2
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<string>(folderName2, "test2");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download context of after import move message operation
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName2, out folderIdIndex2, out folderHandleIndex2);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex2, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 // Implement import move message operation
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
					 SynchronizationImportMessageMove(1,uploadcontextHandleIndex2, folderIdIndex2, folderIdIndex, messageIdIndex,folderHandleIndex2, folderHandleIndex, false, out _, out _);
					 // Implement download content sync in download context.
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 Release(1, uploadcontextHandleIndex2);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsMoveFAI_Scenario machine.
machine S06_SyncICSContentsMoveFAI_SlicedModel() : Actions
{
	S06_SyncICSContentsMoveFAI_Scenario()
	||
    (construct model program from SyncICSContentsMoveFAI where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsMoveFAI_TestSuite machine.
machine S06_SyncICSContentsMoveFAI_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsMoveFAI_SlicedModel
}


// Configure for machine S06_SyncICSContentsFAI
config SyncICSContentsFAI : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Associated);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode|SendOptionAlls.PartialItem);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.FAI,SynchronizationFlag.Unicode|SynchronizationFlag.ReadState, SynchronizationFlag.Unicode|SynchronizationFlag.FAI|SynchronizationFlag.NoDeletions|SynchronizationFlag.IgnoreNoLongerInScope|SynchronizationFlag.ReadState|SynchronizationFlag.OnlySpecifiedProperties|SynchronizationFlag.BestBody|SynchronizationFlag.NoForeignIdentifiers|SynchronizationFlag.Progress);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid,SynchronizationExtraFlag.CN,SynchronizationExtraFlag.OrderByDeliveryTime,SynchronizationExtraFlag.MessageSize);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
        Combination.Interaction(option);
        Combination.Interaction(synchronizationFlag);
        Combination.Interaction(synchronizationExtraFlag);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

// This machine is designed to define the operation sequencing for FAI message object.
// constraint value to FAI message for testing
machine S06_SyncICSContentsFAI_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetSeenFAI,
		ICSStateProperties PidTagCnsetRead,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download FAI message
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 // Implement download FAI message in download context.
					 SynchronizationConfigure(1,folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsFAI_Scenario machine.
machine S06_SyncICSContentsFAI_SlicedModel() : Actions
{
	S06_SyncICSContentsFAI_Scenario()
	||
    (construct model program from SyncICSContentsFAI where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsFAI_TestSuite machine.
machine S06_SyncICSContentsFAI_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsFAI_SlicedModel
}


// Configure for machine S06_SyncICSContentsFAI 
config SyncICSContentsFAI_ConfigWithIgnoreSpecifiedOnFAI : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Associated);
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
}

// This machine is designed to define the operation sequencing for FAI message object.
// IgnoreSpecifiedOnFAI flag is set
machine S06_SyncICSContentsFAIWithIgnoreSpecifiedOnFAI_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetSeenFAI,
		ICSStateProperties PidTagCnsetRead,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex,
		int messageIdIndex,
		int attachmentHandleIndex,
		int uploadcontextHandleIndex,
		int downloadcontextHandleIndex1,
		int downloadcontextHandleIndex2,
		int downloadcontextHandleIndex3,
		Sequence<string> PropertyTags,
		SendOptionAlls sendOption,
		SynchronizationFlag syncFlag1,
		SynchronizationFlag syncFlag2
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagAccess").Add("PidTagDisplayName"));
			 Condition.In<SendOptionAlls>(sendOption, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
			 Condition.In<SynchronizationFlag>(syncFlag1, SynchronizationFlag.IgnoreSpecifiedOnFAI|SynchronizationFlag.FAI);
			 Condition.In<SynchronizationFlag>(syncFlag2, SynchronizationFlag.IgnoreSpecifiedOnFAI|SynchronizationFlag.FAI|SynchronizationFlag.OnlySpecifiedProperties);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download FAI message
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);

					 //Create an attacnment for the new created message
					 CreateAttachment(1,messageHandleIndex, out attachmentHandleIndex);
					 SaveChangesAttachment(1,attachmentHandleIndex);
					 
					 // Implement download FAI message in download context.
					 SynchronizationConfigure(1,folderHandleIndex, SynchronizationTypes.Contents, sendOption, SynchronizationFlag.FAI, SynchronizationExtraFlag.OrderByDeliveryTime, PropertyTags, out downloadcontextHandleIndex1);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetRead,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex1, BufferSize.Normal, out _, out _, out _);
					 
					 SynchronizationConfigure(1,folderHandleIndex, SynchronizationTypes.Contents, sendOption, syncFlag1, SynchronizationExtraFlag.OrderByDeliveryTime, PropertyTags, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, 0);
					 CheckRequirementEnabled(218300301, out _);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2, BufferSize.Normal, out _, out _, out _);

					 SynchronizationConfigure(1,folderHandleIndex, SynchronizationTypes.Contents, sendOption, syncFlag2, SynchronizationExtraFlag.OrderByDeliveryTime, PropertyTags, out downloadcontextHandleIndex3);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetRead,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex3, BufferSize.Normal, out _, out _, out _);
						  
					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, uploadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex1);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex3);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentsFAI_ConfigWithIgnoreSpecifiedOnFAI_Scenario machine.
machine S06_SyncICSContentsFAIWithIgnoreSpecifiedOnFAI_SlicedModel() : Actions
{
	S06_SyncICSContentsFAIWithIgnoreSpecifiedOnFAI_Scenario()
	||
    (construct model program from SyncICSContentsFAI_ConfigWithIgnoreSpecifiedOnFAI where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentsFAI_ConfigWithIgnoreSpecifiedOnFAI_TestSuite machine.
machine S06_SyncICSContentsFAIWithIgnoreSpecifiedOnFAI_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentsFAIWithIgnoreSpecifiedOnFAI_SlicedModel
}

// Configure for machine S06_SyncICSContentAllMessage 
config SyncICSContentAllMessage : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<int>(CMessagIdindex, 0);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode|SendOptionAlls.ForceUnicode);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.OrderByDeliveryTime);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
    action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(0));
    .};
        action RopResult IMS_OXCFXICSAdapter.SynchronizationImportDeletes(int serverId, int uploadcontextHandleIndex, Sequence<int> objIdIndexes, byte ImportDeleteFlag)
    where
    {.
        Condition.In<byte>(ImportDeleteFlag,(byte)ImportDeleteFlags.delete);
    .};
}

// This machine is designed to define the operation sequencing for FAI message object.
// constraint value to FAI message for testing
machine S06_SyncICSContentAllMessage_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetSeenFAI,
		ICSStateProperties PidTagCnsetRead,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		string folderName,
		int messageHandleIndex1,
		int messageIdIndex1,
		int messageHandleIndex2,
		int messageIdIndex2,
		int uploadcontextHandleIndex,
		int uploadcontextHandleIndex1,
		int downloadcontextHandleIndex,
		int downloadcontextHandleIndex1,
		int downloadcontextHandleIndex2,
		int downloadcontextHandleIndex3,
		ImportFlag importFlagForFAI,
		ImportFlag importFlagForNormal,
		SynchronizationFlag synchronizationFlag,
		SynchronizationFlag synchronizationFlag1,
		SynchronizationFlag synchronizationFlag2,
		SynchronizationFlag synchronizationFlag3,
		Sequence<string> PropertyTags
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<Sequence<string>>(PropertyTags,(new Sequence<string>()).Add("PidTagCreationTime"));
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ImportFlag>(importFlagForFAI, ImportFlag.Associated);
			 Condition.In<ImportFlag>(importFlagForNormal, ImportFlag.Normal);
			 Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.FAI|SynchronizationFlag.Normal|SynchronizationFlag.IgnoreSpecifiedOnFAI);
			 Condition.In<SynchronizationFlag>(synchronizationFlag1, SynchronizationFlag.FAI|SynchronizationFlag.Normal);
			 Condition.In<SynchronizationFlag>(synchronizationFlag2, SynchronizationFlag.FAI|SynchronizationFlag.Normal|SynchronizationFlag.OnlySpecifiedProperties);
			 Condition.In<SynchronizationFlag>(synchronizationFlag3, SynchronizationFlag.Normal|SynchronizationFlag.OnlySpecifiedProperties|SynchronizationFlag.IgnoreSpecifiedOnFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 
					 // Complete the precondition for download FAI message
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _, importFlagForFAI, out messageHandleIndex1);
					 SaveChangesMessage(1,messageHandleIndex1, out messageIdIndex1);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, _, importFlagForNormal, out messageHandleIndex2);
					 SaveChangesMessage(1,messageHandleIndex2, out messageIdIndex2);
					 // Implement download FAI message in download context.
					 SynchronizationConfigure(1,folderHandleIndex, _, _, synchronizationFlag, _, PropertyTags, out downloadcontextHandleIndex);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetRead,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _, out _,out _);

					 SynchronizationConfigure(1,folderHandleIndex, _, _, synchronizationFlag1, _, PropertyTags, out downloadcontextHandleIndex1);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetRead,false, 0);
					 CheckRequirementEnabled(218300301, out _);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex1,BufferSize.Normal,out _, out _,out _);

					 SynchronizationConfigure(1,folderHandleIndex, _, _, synchronizationFlag2, _, PropertyTags, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _, out _,out _);

					 SynchronizationConfigure(1,folderHandleIndex, _, _, synchronizationFlag3, _, PropertyTags, out downloadcontextHandleIndex3);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeenFAI,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetRead,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex3,BufferSize.Normal,out _, out _,out _);

					 SetLocalReplicaMidsetDeleted(1, folderHandleIndex,_);
					 Release(1, uploadcontextHandleIndex);
					 //Release(1, uploadcontextHandleIndex1);
					 Release(1, downloadcontextHandleIndex);
					 Release(1, downloadcontextHandleIndex1);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex3);
				)
				|
				return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S06_SyncICSContentAllMessage_Scenario machine.
machine S06_SyncICSContentAllMessage_SlicedModel() : Actions
{
	S06_SyncICSContentAllMessage_Scenario()
	||
    (construct model program from SyncICSContentAllMessage where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S06_SyncICSContentAllMessage_TestSuite machine.
machine S06_SyncICSContentAllMessage_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S06_SyncICSContentAllMessage_SlicedModel
}


// Configure for machine S07_SyncICSState
config SyncICSState : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.Normal);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.Unicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.Normal);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag, SynchronizationExtraFlag.Eid, SynchronizationExtraFlag.CN);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagCreationTime"));
    .};
}


// This machine is designed to download the state in the download context.
machine S07_SyncICSStateDownload_Scenario() : Actions
{
	(
		let
		// The data used in this machine
		ICSStateProperties PidTagIdsetGiven,
		ICSStateProperties PidTagCnsetSeen,
		ICSStateProperties PidTagCnsetRead,
		ICSStateProperties PidTagCnsetSeenFAI,
		int logonHandleIndex,
		int inboxFolderIdIndex,
		int inboxFolderHandleIndex,
		int folderIdIndex,
		int folderHandleIndex,
		int messageIdIndex,
		int messageHandleIndex,
		string folderName,
		AbstractFastTransferStream fastTransferStream,
		int ICSStateIndex,
		int uploadcontextHandleIndex1,
		int downloadcontextHandleIndex1,
		int downloadcontextHandleIndex2,
		int downloadcontextHandleIndex3
		where
		{.
			 Condition.In<string>(folderName, "test");
			 Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
			 Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
			 Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
		.}
		in
		(
			call CheckMAPIHTTPTransportSupported(out _);
			(
				(
					 return CheckMAPIHTTPTransportSupported(out true);
					 // Complete the precondition for download the state in the download context.
					 Connect(1, ConnectionType.PrivateMailboxServer);
					 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
					 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
					 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
					 GetLocalReplicaIds(1, logonHandleIndex, 3);
					 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex1);
					 SynchronizationImportMessageChange(1, uploadcontextHandleIndex1,0,_, out messageHandleIndex);
					 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex1);
					 CheckRequirementEnabled(2657, out _);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagIdsetGiven,true, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeen,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetRead,false, 0);
					 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeenFAI,false, 0);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex1,BufferSize.Normal,out _,out fastTransferStream,out _);
					 {.
						Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
					 .}:
					 // Implement download the state in the download context.
					 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen,false, ICSStateIndex);
					 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetRead,false, ICSStateIndex);
					 SynchronizationGetTransferState(1, downloadcontextHandleIndex2, out downloadcontextHandleIndex3);
					 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex3,BufferSize.Normal,out _,out _,out _);
					 Release(1, downloadcontextHandleIndex3);
					 Release(1, downloadcontextHandleIndex2);
					 Release(1, downloadcontextHandleIndex1);
					 Release(1, uploadcontextHandleIndex1);
				 )
				 |
				 return CheckMAPIHTTPTransportSupported(out false);
		   );
		)
	)
}

// Sliced model based on the S07_SyncICSStateDownload_Scenario machine.
machine S07_SyncICSStateDownload_SlicedModel() : Actions
{
	S07_SyncICSStateDownload_Scenario()
	||
    (construct model program from SyncICSState where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S07_SyncICSStateDownload_TestSuite machine.
machine S07_SyncICSStateDownload_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S07_SyncICSStateDownload_SlicedModel
}

// This machine is designed to download the state in the upload context.
machine S07_SyncICSStateUpload_Scenario() : Actions
{
  (
    let
    // The data used in this machine.
    ICSStateProperties PidTagIdsetGiven,
    ICSStateProperties PidTagCnsetSeen,
    ICSStateProperties PidTagCnsetRead,
    ICSStateProperties PidTagCnsetSeenFAI,
    int logonHandleIndex,
    int inboxFolderIdIndex,
    int inboxFolderHandleIndex,
    int folderIdIndex,
    int folderHandleIndex,
    int messageIdIndex,
    int messageHandleIndex,
    string folderName,
    AbstractFastTransferStream fastTransferStream,
    int ICSStateIndex,
    int uploadcontextHandleIndex1,
    int uploadcontextHandleIndex2,
    int downloadcontextHandleIndex1,
    int downloadcontextHandleIndex2
    where
    {.
         Condition.In<string>(folderName, "test");
         Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
         Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
         Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
         Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
    .}
    in
    (
		call CheckMAPIHTTPTransportSupported(out _);
		(
			(
				 return CheckMAPIHTTPTransportSupported(out true);
				 // Complete the precondition for download the state in the upload context.
				 Connect(1, ConnectionType.PrivateMailboxServer);
				 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
				 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
				 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
				 GetLocalReplicaIds(1, logonHandleIndex, 3);
				 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex1);
				 SynchronizationImportMessageChange(1, uploadcontextHandleIndex1,0,_, out messageHandleIndex);
				 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
				 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex1);
				 CheckRequirementEnabled(2657, out _);
				 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagIdsetGiven,true, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeen,false, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetRead,false, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex1, PidTagCnsetSeenFAI,false, 0);
				 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex1,BufferSize.Normal,out _,out fastTransferStream,out _);
				 {.
					Condition.In<int>(ICSStateIndex, fastTransferStream.AbstractContentsSync.FinalICSState.AbstractICSStateIndex);
				 .}:
				 // Implement download the state in the upload context.
				 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex2);
				 SynchronizationUploadState(1, uploadcontextHandleIndex2, PidTagIdsetGiven,true, ICSStateIndex):
				 {.
					 ModelHelper.CaptureRequirement(3359,"[In Sending and Receiving the PidTagIdsetGiven ICS State Property] However, if the client does not remove this property [PidTagIdsetGiven property] before uploading the initial ICS state, there is no server impact.");
				 .};
				 SynchronizationUploadState(1, uploadcontextHandleIndex2, PidTagCnsetSeen,false, ICSStateIndex);
				 SynchronizationUploadState(1, uploadcontextHandleIndex2, PidTagCnsetRead,false, ICSStateIndex);
				 CheckRequirementEnabled(350400101, out _); 
				 SynchronizationGetTransferState(1, uploadcontextHandleIndex2, out downloadcontextHandleIndex2);
				 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
				 Release(1, downloadcontextHandleIndex2);
				 Release(1, downloadcontextHandleIndex1);
				 Release(1, uploadcontextHandleIndex2);
				 Release(1, uploadcontextHandleIndex1);
			 )
			 |
		     return CheckMAPIHTTPTransportSupported(out false);
	   );
    )
   )
}

// Sliced model based on the S07_SyncICSStateUpload_Scenario machine.
machine S07_SyncICSStateUpload_SlicedModel() : Actions
{
	S07_SyncICSStateUpload_Scenario()
	||
    (construct model program from SyncICSState where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S07_SyncICSStateUpload_TestSuite machine.
machine S07_SyncICSStateUpload_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S07_SyncICSStateUpload_SlicedModel
}


// Configure for machine S08_SyncICSFolderConflict
config SyncICSFolderConflict : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationConfigure(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, SendOptionAlls option, SynchronizationFlag synchronizationFlag, SynchronizationExtraFlag synchronizationExtraFlag, Sequence<string> property, out int downloadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Hierarchy);
        Condition.In<SendOptionAlls>(option, SendOptionAlls.ForceUnicode|SendOptionAlls.Unicode);
        Condition.In<SynchronizationFlag>(synchronizationFlag, SynchronizationFlag.Unicode|SynchronizationFlag.NoForeignIdentifiers);
        Condition.In<SynchronizationExtraFlag>(synchronizationExtraFlag,SynchronizationExtraFlag.Eid);
        Condition.In<Sequence<string>>(property, (new Sequence<string>()).Add("PidTagAttachLongFilename"));
        Combination.Pairwise(option, synchronizationFlag, synchronizationExtraFlag);
    .};
     action RopResult IMS_OXCFXICSAdapter.SetLocalReplicaMidsetDeleted(int serverId, int FolderhandleIndex, Sequence<int> LongTermIdRangeIndex)
    where
    {.
        Condition.In<Sequence<int>>(LongTermIdRangeIndex, (new Sequence<int>()).Add(1).Add(2));
    .};
}

// This machine is designed to verify the conflict for uploading folder.
machine S08_SyncICSFolderConflict_Scenario() : Actions
{
  (
    let
    ICSStateProperties PidTagIdsetGiven,
    ICSStateProperties PidTagCnsetSeen,
    int serverId,
    int logonHandleIndex,
    int inboxFolderIdIndex,
    int inboxFolderHandleIndex,
    int folderIdIndex,
    int folderHandleIndex,
    Set<string> properties,
    string folderName,
    int uploadcontextHandleIndex,
    int uploadcontextHandleIndex2,
    int uploadcontextHandleIndex3,
    int uploadcontextHandleIndex4,
    int downloadcontextHandleIndex,
    int downloadcontextHandleIndex2,
    int downloadcontextHandleIndex3,
    int downloadcontextHandleIndex4,
    Sequence<string> propertyTags,
    ConflictTypes conflictType
    where
    {.
        Condition.In<int>(serverId, 1);
        Condition.In<string>(folderName, "test");
        Condition.In<Set<string>>(properties, (new Set<string>()).Add("PidTagFolderType"));
        Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
        Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
        Condition.In<Sequence<string>>(propertyTags,new Sequence<string>().Add("PidTagPredecessorChangeList").Add("PidTagChangeKey"));
    .}
    in
    (
		call CheckMAPIHTTPTransportSupported(out _);
		(
			(
				 return CheckMAPIHTTPTransportSupported(out true);
				 // Precondition for folder conflict.
				 Connect(serverId, ConnectionType.PrivateMailboxServer);
				 Logon(serverId, _, out logonHandleIndex, out inboxFolderIdIndex);
				 OpenFolder(serverId, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
				 CreateFolder(serverId, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
				 GetLocalReplicaIds(serverId, logonHandleIndex, 3);
				 CheckRequirementEnabled(2734, out _);
				 SynchronizationOpenCollector(serverId,folderHandleIndex,_,out uploadcontextHandleIndex);
				 SynchronizationImportHierarchyChange(1, uploadcontextHandleIndex, folderHandleIndex, properties, 0, out _);
				 // Implement download folder change in download context
				 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex);
				 CheckRequirementEnabled(2657, out _);
				 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagIdsetGiven,true, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex, PidTagCnsetSeen, false, 0);
				 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex,BufferSize.Normal,out _,out _,out _);

				 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex2);
				 SynchronizationImportHierarchyChangeWithConflict(1, uploadcontextHandleIndex2, folderHandleIndex, properties, 0, out _, ConflictTypes.AINCLUDEB );
				 // Implement download folder change in download context
				 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex2);
				 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagIdsetGiven,true, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex2, PidTagCnsetSeen, false, 0);
				 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex2,BufferSize.Normal,out _,out _,out _);
				 
				 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex3);
				 SynchronizationImportHierarchyChangeWithConflict(1, uploadcontextHandleIndex3, folderHandleIndex, properties, 0, out _, ConflictTypes.BINCLUDEA );
				 // Implement download folder change in download context
				 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex3);
				 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagIdsetGiven,true, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex3, PidTagCnsetSeen, false, 0);
				 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex3,BufferSize.Normal,out _,out _,out _);
				 
				 SynchronizationOpenCollector(1,folderHandleIndex,_, out uploadcontextHandleIndex4);
				 SynchronizationImportHierarchyChangeWithConflict(1, uploadcontextHandleIndex4, folderHandleIndex, properties, 0, out _, ConflictTypes.CONFLICT);
				 // Implement download folder change in download context
				 SynchronizationConfigure(1, folderHandleIndex, _,_, _,_,_, out downloadcontextHandleIndex4);
				 SynchronizationUploadState(1, downloadcontextHandleIndex4, PidTagIdsetGiven,true, 0);
				 SynchronizationUploadState(1, downloadcontextHandleIndex4, PidTagCnsetSeen, false, 0);
				 FastTransferSourceGetBuffer(1,downloadcontextHandleIndex4,BufferSize.Normal,out _,out _,out _);
				 Release(serverId, uploadcontextHandleIndex);
				 Release(serverId, uploadcontextHandleIndex2);
				 Release(serverId, uploadcontextHandleIndex3);
				 Release(serverId, downloadcontextHandleIndex);
				 Release(serverId, downloadcontextHandleIndex2);
				 Release(serverId, downloadcontextHandleIndex3);
			 )
			 |
		     return CheckMAPIHTTPTransportSupported(out false);
	   );
    )
   )
}

// Sliced model based on the S08_SyncICSFolderConflict_Scenario machine.
machine S08_SyncICSFolderConflict_SlicedModel() : Actions
{
	S08_SyncICSFolderConflict_Scenario()
	||
    (construct model program from SyncICSFolderConflict where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S08_SyncICSFolderConflict_TestSuite machine.
machine S08_SyncICSFolderConflict_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S08_SyncICSFolderConflict_SlicedModel
}

// Configure for machine S09_SyncICSMessageConflict
config SyncICSMessageConflict : Actions
{
    action RopResult IMS_OXCFXICSAdapter.Logon(int serverId, LogonFlags flag, out int logonHandleIndex, out int inboxFolderIdIndex)
    where
    {.
        Condition.In<LogonFlags>(flag, LogonFlags.Private);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationOpenCollector(int serverId, int folderHandleIndex, SynchronizationTypes SynchronizationTypes, out int uploadcontextHandleIndex)
    where
    {.
        Condition.In<SynchronizationTypes>(SynchronizationTypes, SynchronizationTypes.Contents);
    .};
    action RopResult IMS_OXCFXICSAdapter.SynchronizationImportMessageChange(int serverId, int uploadcontextHandleIndex, int CMessagIdindex, ImportFlag ImportFlag, out int ImportMessageHandleIndex)
    where
    {.
        Condition.In<ImportFlag>(ImportFlag, ImportFlag.FailOnConflict,ImportFlag.Normal);
    .};
    action RopResult IMS_OXCFXICSAdapter.GetLocalReplicaIds(int serverId, int objHandleIndex, uint IdCount)
    where
    {.
        Condition.In<uint>(IdCount, 3);
    .};
}

// This machine is designed to verify the conflict for uploading message.
machine S09_SyncICSMessageConflict_Scenario() : Actions
{
  (
   let
    ICSStateProperties PidTagIdsetGiven,
    ICSStateProperties PidTagCnsetSeen,
    ICSStateProperties PidTagCnsetRead,
    ICSStateProperties PidTagCnsetSeenFAI,
    int serverId,
    int logonHandleIndex,
    int inboxFolderIdIndex,
    int inboxFolderHandleIndex,
    int folderIdIndex,
    int folderHandleIndex,
    Set<string> properties,
    string folderName,
    int uploadcontextHandleIndex,
    int uploadcontextHandleIndex2,
    int uploadcontextHandleIndex3,
    int downloadcontextHandleIndex,
    int outhandler1,
    int outhandler2,
    int conflictType,
    int messageIdIndex,
    int messageIdIndex2,
    int messageIdIndex3,
    int messageIdIndex4,
    int messageHandleIndex,
    int messageHandleIndex2,
    int messageHandleIndex3,
    int messageHandleIndex4,
    ImportFlag flag,
    Sequence<string> propertyTags
    where
    {.
         Condition.In<int>(serverId, 1);
         Condition.In<string>(folderName, "test");
         Condition.In<ICSStateProperties>(PidTagIdsetGiven, ICSStateProperties.PidTagIdsetGiven);
         Condition.In<ICSStateProperties>(PidTagCnsetSeen, ICSStateProperties.PidTagCnsetSeen);
         Condition.In<ICSStateProperties>(PidTagCnsetRead, ICSStateProperties.PidTagCnsetRead);
         Condition.In<ICSStateProperties>(PidTagCnsetSeenFAI, ICSStateProperties.PidTagCnsetSeenFAI);
         Condition.In<Sequence<string>>(propertyTags,new Sequence<string>().Add("PidTagPredecessorChangeList").Add("PidTagChangeKey").Add("PidTagResolveMethod"));
         Condition.In<ImportFlag> (flag, ImportFlag.Normal,ImportFlag.FailOnConflict);
    .}
    in
    (
		call CheckMAPIHTTPTransportSupported(out _);
		(
			(
				 return CheckMAPIHTTPTransportSupported(out true);
				 // Precondition for folder conflict.
				 Connect(1, ConnectionType.PrivateMailboxServer);
				 Logon(1, _, out logonHandleIndex, out inboxFolderIdIndex);
				 OpenFolder(1, logonHandleIndex, inboxFolderIdIndex, out inboxFolderHandleIndex);
				 //CheckRequirementEnabled(2734, out _);

				 CreateFolder(1, inboxFolderHandleIndex, folderName, out folderIdIndex, out folderHandleIndex);
				 CreateMessage(1,folderHandleIndex, folderIdIndex, false, out messageHandleIndex);
				 SaveChangesMessage(1,messageHandleIndex, out messageIdIndex);
				 GetLocalReplicaIds(1, logonHandleIndex, 3);
				 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex);
				 GetPropertiesSpecific(1,messageHandleIndex, propertyTags);
				 SynchronizationImportMessageChange(1, uploadcontextHandleIndex, -1,flag, out messageHandleIndex2);
				 SaveChangesMessage(1,messageHandleIndex2, out messageIdIndex2);

				 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex2);
				 SynchronizationImportMessageChange(1, uploadcontextHandleIndex2, -2,flag, out messageHandleIndex3);
				 SaveChangesMessage(1,messageHandleIndex3, out messageIdIndex3);

				 SynchronizationOpenCollector(1,folderHandleIndex, _, out uploadcontextHandleIndex3);
				 SynchronizationImportMessageChange(1, uploadcontextHandleIndex3, -2,flag, out messageHandleIndex4);
				 SaveChangesMessage(1,messageHandleIndex4, out messageIdIndex4);
				 Release(serverId, uploadcontextHandleIndex);
				 Release(serverId, uploadcontextHandleIndex2);
				 Release(serverId, uploadcontextHandleIndex3);
				 Release(serverId, messageHandleIndex);
				 Release(serverId, messageHandleIndex2);
				 Release(serverId, messageHandleIndex3);
				 Release(serverId, messageHandleIndex4);
			 )
			 |
		     return CheckMAPIHTTPTransportSupported(out false);
	   );
    )
   )
}

// Sliced model based on the S09_SyncICSMessageConflict_Scenario machine.
machine S09_SyncICSMessageConflict_SlicedModel() : Actions
{
	S09_SyncICSMessageConflict_Scenario()
	||
    (construct model program from SyncICSMessageConflict where scope = "Microsoft.Protocols.TestSuites.MS_OXCFXICS")
}

//This machine is designed to generate test case for 
//S09_SyncICSMessageConflict_TestSuite machine.
machine S09_SyncICSMessageConflict_TestSuite() : Actions where TestEnabled = true
{
    construct test cases where strategy = "ShortTests", AllowUndeterminedCoverage = true for S09_SyncICSMessageConflict_SlicedModel
}